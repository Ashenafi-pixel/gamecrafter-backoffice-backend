// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: street_kings.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const closeStreetKingGameByID = `-- name: CloseStreetKingGameByID :one
UPDATE street_kings set status = $1 , won_amount = $2 ,cash_out_point = $3 
WHERE id = $4 RETURNING id, user_id, status, version, bet_amount, won_amount, crash_point, cash_out_point, timestamp
`

type CloseStreetKingGameByIDParams struct {
	Status       string
	WonAmount    decimal.NullDecimal
	CashOutPoint decimal.NullDecimal
	ID           uuid.UUID
}

func (q *Queries) CloseStreetKingGameByID(ctx context.Context, arg CloseStreetKingGameByIDParams) (StreetKing, error) {
	row := q.db.QueryRow(ctx, closeStreetKingGameByID,
		arg.Status,
		arg.WonAmount,
		arg.CashOutPoint,
		arg.ID,
	)
	var i StreetKing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Version,
		&i.BetAmount,
		&i.WonAmount,
		&i.CrashPoint,
		&i.CashOutPoint,
		&i.Timestamp,
	)
	return i, err
}

const createStreetKingsGame = `-- name: CreateStreetKingsGame :one
INSERT INTO street_kings (user_id,version,bet_amount,crash_point,timestamp)
VALUES($1,$2,$3,$4,$5) RETURNING id, user_id, status, version, bet_amount, won_amount, crash_point, cash_out_point, timestamp
`

type CreateStreetKingsGameParams struct {
	UserID     uuid.UUID
	Version    string
	BetAmount  decimal.Decimal
	CrashPoint decimal.Decimal
	Timestamp  time.Time
}

func (q *Queries) CreateStreetKingsGame(ctx context.Context, arg CreateStreetKingsGameParams) (StreetKing, error) {
	row := q.db.QueryRow(ctx, createStreetKingsGame,
		arg.UserID,
		arg.Version,
		arg.BetAmount,
		arg.CrashPoint,
		arg.Timestamp,
	)
	var i StreetKing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Version,
		&i.BetAmount,
		&i.WonAmount,
		&i.CrashPoint,
		&i.CashOutPoint,
		&i.Timestamp,
	)
	return i, err
}

const getStreetKingsGameByID = `-- name: GetStreetKingsGameByID :one
SELECT id, user_id, status, version, bet_amount, won_amount, crash_point, cash_out_point, timestamp FROM street_kings where id = $1
`

func (q *Queries) GetStreetKingsGameByID(ctx context.Context, id uuid.UUID) (StreetKing, error) {
	row := q.db.QueryRow(ctx, getStreetKingsGameByID, id)
	var i StreetKing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Version,
		&i.BetAmount,
		&i.WonAmount,
		&i.CrashPoint,
		&i.CashOutPoint,
		&i.Timestamp,
	)
	return i, err
}

const getStreetKingsGamesByUserIDAndVersion = `-- name: GetStreetKingsGamesByUserIDAndVersion :many
WITH crash_king_data AS (
    SELECT id, user_id, status, version, bet_amount, won_amount, crash_point, cash_out_point, timestamp
    FROM street_kings
    WHERE user_id = $1 AND version = $2 and status = 'CLOSED' 
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM crash_king_data
     WHERE user_id = $1 AND status = 'CLOSED'
)
SELECT c.id, c.user_id, c.status, c.version, c.bet_amount, c.won_amount, c.crash_point, c.cash_out_point, c.timestamp, r.total_rows
FROM crash_king_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $3 OFFSET $4
`

type GetStreetKingsGamesByUserIDAndVersionParams struct {
	UserID  uuid.UUID
	Version string
	Limit   int32
	Offset  int32
}

type GetStreetKingsGamesByUserIDAndVersionRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	Status       string
	Version      string
	BetAmount    decimal.Decimal
	WonAmount    decimal.NullDecimal
	CrashPoint   decimal.Decimal
	CashOutPoint decimal.NullDecimal
	Timestamp    time.Time
	TotalRows    int64
}

func (q *Queries) GetStreetKingsGamesByUserIDAndVersion(ctx context.Context, arg GetStreetKingsGamesByUserIDAndVersionParams) ([]GetStreetKingsGamesByUserIDAndVersionRow, error) {
	rows, err := q.db.Query(ctx, getStreetKingsGamesByUserIDAndVersion,
		arg.UserID,
		arg.Version,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetStreetKingsGamesByUserIDAndVersionRow
	for rows.Next() {
		var i GetStreetKingsGamesByUserIDAndVersionRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.Version,
			&i.BetAmount,
			&i.WonAmount,
			&i.CrashPoint,
			&i.CashOutPoint,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

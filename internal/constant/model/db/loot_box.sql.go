// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: loot_box.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
	"github.com/shopspring/decimal"
)

const createLootBox = `-- name: CreateLootBox :one
INSERT INTO loot_box (type, prizeAmount, weight)
VALUES ($1, $2, $3)
RETURNING id, type, prizeamount, weight, created_at, updated_at
`

type CreateLootBoxParams struct {
	Type        string
	Prizeamount decimal.Decimal
	Weight      decimal.Decimal
}

func (q *Queries) CreateLootBox(ctx context.Context, arg CreateLootBoxParams) (LootBox, error) {
	row := q.db.QueryRow(ctx, createLootBox, arg.Type, arg.Prizeamount, arg.Weight)
	var i LootBox
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Prizeamount,
		&i.Weight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteLootBoxByID = `-- name: DeleteLootBoxByID :exec
DELETE FROM loot_box WHERE id = $1
`

func (q *Queries) DeleteLootBoxByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLootBoxByID, id)
	return err
}

const getAllLootBoxes = `-- name: GetAllLootBoxes :many
SELECT id,type,prizeAmount,weight FROM loot_box
`

type GetAllLootBoxesRow struct {
	ID          uuid.UUID
	Type        string
	Prizeamount decimal.Decimal
	Weight      decimal.Decimal
}

func (q *Queries) GetAllLootBoxes(ctx context.Context) ([]GetAllLootBoxesRow, error) {
	rows, err := q.db.Query(ctx, getAllLootBoxes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLootBoxesRow
	for rows.Next() {
		var i GetAllLootBoxesRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Prizeamount,
			&i.Weight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLootBoxBetByID = `-- name: GetLootBoxBetByID :one
SELECT id, user_id, user_selection, loot_box, wonStatus, status, created_at, updated_at 
FROM loot_box_place_bets
WHERE id = $1 and status = 'pending'
`

func (q *Queries) GetLootBoxBetByID(ctx context.Context, id uuid.UUID) (LootBoxPlaceBet, error) {
	row := q.db.QueryRow(ctx, getLootBoxBetByID, id)
	var i LootBoxPlaceBet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserSelection,
		&i.LootBox,
		&i.Wonstatus,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLootBoxBetsByUserID = `-- name: GetLootBoxBetsByUserID :many
WITH user_bets AS (
    SELECT id, user_id, user_selection, loot_box, wonStatus, status, created_at, updated_at
    FROM loot_box_place_bets
    WHERE user_id = $1 ORDER BY created_at DESC
)
SELECT id, user_id, user_selection, loot_box, wonStatus, status, created_at, updated_at
FROM user_bets LIMIT $2 OFFSET $3
`

type GetLootBoxBetsByUserIDParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetLootBoxBetsByUserIDRow struct {
	ID            uuid.UUID
	UserID        uuid.UUID
	UserSelection uuid.NullUUID
	LootBox       pgtype.JSONB
	Wonstatus     string
	Status        string
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) GetLootBoxBetsByUserID(ctx context.Context, arg GetLootBoxBetsByUserIDParams) ([]GetLootBoxBetsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getLootBoxBetsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLootBoxBetsByUserIDRow
	for rows.Next() {
		var i GetLootBoxBetsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserSelection,
			&i.LootBox,
			&i.Wonstatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLootBoxByID = `-- name: GetLootBoxByID :one
SELECT id,type,prizeAmount,weight FROM loot_box WHERE id = $1
`

type GetLootBoxByIDRow struct {
	ID          uuid.UUID
	Type        string
	Prizeamount decimal.Decimal
	Weight      decimal.Decimal
}

func (q *Queries) GetLootBoxByID(ctx context.Context, id uuid.UUID) (GetLootBoxByIDRow, error) {
	row := q.db.QueryRow(ctx, getLootBoxByID, id)
	var i GetLootBoxByIDRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Prizeamount,
		&i.Weight,
	)
	return i, err
}

const getLootBoxByType = `-- name: GetLootBoxByType :many
SELECT id,type,prizeAmount,weight FROM loot_box WHERE type = $1
`

type GetLootBoxByTypeRow struct {
	ID          uuid.UUID
	Type        string
	Prizeamount decimal.Decimal
	Weight      decimal.Decimal
}

func (q *Queries) GetLootBoxByType(ctx context.Context, type_ string) ([]GetLootBoxByTypeRow, error) {
	rows, err := q.db.Query(ctx, getLootBoxByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLootBoxByTypeRow
	for rows.Next() {
		var i GetLootBoxByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Prizeamount,
			&i.Weight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const placeLootBoxBet = `-- name: PlaceLootBoxBet :one
INSERT INTO loot_box_place_bets (user_id,loot_box)
VALUES ($1, $2)
RETURNING id, user_id, user_selection, loot_box, wonstatus, status, created_at, updated_at
`

type PlaceLootBoxBetParams struct {
	UserID  uuid.UUID
	LootBox pgtype.JSONB
}

func (q *Queries) PlaceLootBoxBet(ctx context.Context, arg PlaceLootBoxBetParams) (LootBoxPlaceBet, error) {
	row := q.db.QueryRow(ctx, placeLootBoxBet, arg.UserID, arg.LootBox)
	var i LootBoxPlaceBet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserSelection,
		&i.LootBox,
		&i.Wonstatus,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLootBox = `-- name: UpdateLootBox :one
UPDATE loot_box SET
    type = $1,
    prizeAmount = $2,
    weight = $3,
    updated_at = NOW()
WHERE id = $4
RETURNING id, type, prizeamount, weight, created_at, updated_at
`

type UpdateLootBoxParams struct {
	Type        string
	Prizeamount decimal.Decimal
	Weight      decimal.Decimal
	ID          uuid.UUID
}

func (q *Queries) UpdateLootBox(ctx context.Context, arg UpdateLootBoxParams) (LootBox, error) {
	row := q.db.QueryRow(ctx, updateLootBox,
		arg.Type,
		arg.Prizeamount,
		arg.Weight,
		arg.ID,
	)
	var i LootBox
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Prizeamount,
		&i.Weight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateLootBoxBet = `-- name: UpdateLootBoxBet :one
UPDATE loot_box_place_bets SET
    user_selection = $1,
    wonStatus = $2,
    status = $3,
    updated_at = NOW()
WHERE id = $4
RETURNING id, user_id, user_selection, loot_box, wonstatus, status, created_at, updated_at
`

type UpdateLootBoxBetParams struct {
	UserSelection uuid.NullUUID
	Wonstatus     string
	Status        string
	ID            uuid.UUID
}

func (q *Queries) UpdateLootBoxBet(ctx context.Context, arg UpdateLootBoxBetParams) (LootBoxPlaceBet, error) {
	row := q.db.QueryRow(ctx, updateLootBoxBet,
		arg.UserSelection,
		arg.Wonstatus,
		arg.Status,
		arg.ID,
	)
	var i LootBoxPlaceBet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserSelection,
		&i.LootBox,
		&i.Wonstatus,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

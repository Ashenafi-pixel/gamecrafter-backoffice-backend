// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: currency.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createCurrency = `-- name: CreateCurrency :one
INSERT INTO currencies(name) VALUES($1) RETURNING id, name, status, timestamp
`

func (q *Queries) CreateCurrency(ctx context.Context, name string) (Currency, error) {
	row := q.db.QueryRow(ctx, createCurrency, name)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const getAvailableCurrencies = `-- name: GetAvailableCurrencies :many
WITH currency_data AS (
    SELECT id, name, status, timestamp
    FROM currencies where status ='ACTIVE'
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM currency_data
)
SELECT c.id, c.name, c.status, c.timestamp, r.total_rows
FROM currency_data c
CROSS JOIN row_count r
ORDER BY c.name ASC
LIMIT $1 OFFSET $2
`

type GetAvailableCurrenciesParams struct {
	Limit  int32
	Offset int32
}

type GetAvailableCurrenciesRow struct {
	ID        uuid.UUID
	Name      string
	Status    string
	Timestamp time.Time
	TotalRows int64
}

func (q *Queries) GetAvailableCurrencies(ctx context.Context, arg GetAvailableCurrenciesParams) ([]GetAvailableCurrenciesRow, error) {
	rows, err := q.db.Query(ctx, getAvailableCurrencies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableCurrenciesRow
	for rows.Next() {
		var i GetAvailableCurrenciesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCurrency = `-- name: GetCurrency :many
WITH currency_data AS (
    SELECT id, name, status, timestamp
    FROM currencies
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM currency_data
)
SELECT c.id, c.name, c.status, c.timestamp, r.total_rows
FROM currency_data c
CROSS JOIN row_count r
ORDER BY c.name ASC
LIMIT $1 OFFSET $2
`

type GetCurrencyParams struct {
	Limit  int32
	Offset int32
}

type GetCurrencyRow struct {
	ID        uuid.UUID
	Name      string
	Status    string
	Timestamp time.Time
	TotalRows int64
}

func (q *Queries) GetCurrency(ctx context.Context, arg GetCurrencyParams) ([]GetCurrencyRow, error) {
	rows, err := q.db.Query(ctx, getCurrency, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCurrencyRow
	for rows.Next() {
		var i GetCurrencyRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCurrencyStatus = `-- name: UpdateCurrencyStatus :one
UPDATE currencies set status = $1 where id =$2 RETURNING id, name, status, timestamp
`

type UpdateCurrencyStatusParams struct {
	Status string
	ID     uuid.UUID
}

func (q *Queries) UpdateCurrencyStatus(ctx context.Context, arg UpdateCurrencyStatusParams) (Currency, error) {
	row := q.db.QueryRow(ctx, updateCurrencyStatus, arg.Status, arg.ID)
	var i Currency
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crypto_kings.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createCryptoKings = `-- name: CreateCryptoKings :one
insert into crypto_kings(
    user_id,
    status,
    bet_amount,
    won_amount,
    start_crypto_value,
    end_crypto_value,
    selected_end_second,
    selected_start_value,
    selected_end_value,
    won_status,
    type,
    timestamp
    )
 VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12
 ) RETURNING id, user_id, status, bet_amount, won_amount, start_crypto_value, end_crypto_value, selected_end_second, selected_start_value, selected_end_value, won_status, type, timestamp
`

type CreateCryptoKingsParams struct {
	UserID             uuid.UUID
	Status             string
	BetAmount          decimal.Decimal
	WonAmount          decimal.NullDecimal
	StartCryptoValue   decimal.Decimal
	EndCryptoValue     decimal.Decimal
	SelectedEndSecond  sql.NullInt32
	SelectedStartValue decimal.NullDecimal
	SelectedEndValue   decimal.NullDecimal
	WonStatus          string
	Type               string
	Timestamp          time.Time
}

func (q *Queries) CreateCryptoKings(ctx context.Context, arg CreateCryptoKingsParams) (CryptoKing, error) {
	row := q.db.QueryRow(ctx, createCryptoKings,
		arg.UserID,
		arg.Status,
		arg.BetAmount,
		arg.WonAmount,
		arg.StartCryptoValue,
		arg.EndCryptoValue,
		arg.SelectedEndSecond,
		arg.SelectedStartValue,
		arg.SelectedEndValue,
		arg.WonStatus,
		arg.Type,
		arg.Timestamp,
	)
	var i CryptoKing
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.BetAmount,
		&i.WonAmount,
		&i.StartCryptoValue,
		&i.EndCryptoValue,
		&i.SelectedEndSecond,
		&i.SelectedStartValue,
		&i.SelectedEndValue,
		&i.WonStatus,
		&i.Type,
		&i.Timestamp,
	)
	return i, err
}

const getCrytoKingsBetHistoryByUserID = `-- name: GetCrytoKingsBetHistoryByUserID :many
 WITH crash_king_data AS (
    SELECT id, user_id, status, bet_amount, won_amount, start_crypto_value, end_crypto_value, selected_end_second, selected_start_value, selected_end_value, won_status, type, timestamp
    FROM crypto_kings
    WHERE user_id = $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM crash_king_data  WHERE user_id = $1
)
SELECT c.id, c.user_id, c.status, c.bet_amount, c.won_amount, c.start_crypto_value, c.end_crypto_value, c.selected_end_second, c.selected_start_value, c.selected_end_value, c.won_status, c.type, c.timestamp, r.total_rows
FROM crash_king_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $2 OFFSET $3
`

type GetCrytoKingsBetHistoryByUserIDParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetCrytoKingsBetHistoryByUserIDRow struct {
	ID                 uuid.UUID
	UserID             uuid.UUID
	Status             string
	BetAmount          decimal.Decimal
	WonAmount          decimal.NullDecimal
	StartCryptoValue   decimal.Decimal
	EndCryptoValue     decimal.Decimal
	SelectedEndSecond  sql.NullInt32
	SelectedStartValue decimal.NullDecimal
	SelectedEndValue   decimal.NullDecimal
	WonStatus          string
	Type               string
	Timestamp          time.Time
	TotalRows          int64
}

func (q *Queries) GetCrytoKingsBetHistoryByUserID(ctx context.Context, arg GetCrytoKingsBetHistoryByUserIDParams) ([]GetCrytoKingsBetHistoryByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getCrytoKingsBetHistoryByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCrytoKingsBetHistoryByUserIDRow
	for rows.Next() {
		var i GetCrytoKingsBetHistoryByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.BetAmount,
			&i.WonAmount,
			&i.StartCryptoValue,
			&i.EndCryptoValue,
			&i.SelectedEndSecond,
			&i.SelectedStartValue,
			&i.SelectedEndValue,
			&i.WonStatus,
			&i.Type,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

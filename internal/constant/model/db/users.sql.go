// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
	"github.com/shopspring/decimal"
)

const addReferalCode = `-- name: AddReferalCode :exec
UPDATE users set referal_code = $1 where id = $2
`

type AddReferalCodeParams struct {
	ReferalCode sql.NullString
	ID          uuid.UUID
}

func (q *Queries) AddReferalCode(ctx context.Context, arg AddReferalCodeParams) error {
	_, err := q.db.Exec(ctx, addReferalCode, arg.ReferalCode, arg.ID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (phone_number,password,default_currency,email,source,referal_code,date_of_birth,created_by,is_admin,first_name,last_name,referal_type,refered_by_code,user_type,status) 
values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15) RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

type CreateUserParams struct {
	PhoneNumber     sql.NullString
	Password        string
	DefaultCurrency sql.NullString
	Email           sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	DateOfBirth     sql.NullString
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	FirstName       sql.NullString
	LastName        sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	Status          sql.NullString
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.PhoneNumber,
		arg.Password,
		arg.DefaultCurrency,
		arg.Email,
		arg.Source,
		arg.ReferalCode,
		arg.DateOfBirth,
		arg.CreatedBy,
		arg.IsAdmin,
		arg.FirstName,
		arg.LastName,
		arg.ReferalType,
		arg.ReferedByCode,
		arg.UserType,
		arg.Status,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const deleteOTP = `-- name: DeleteOTP :exec
DELETE from users_otp where user_id = $1
`

func (q *Queries) DeleteOTP(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOTP, userID)
	return err
}

const getAddminAssignedPoints = `-- name: GetAddminAssignedPoints :many
SELECT 
    user_id,
    change_amount,
    timestamp,
    description,
	balance_after_update,
    transaction_id,
    COUNT(id) AS total
FROM 
    balance_logs
WHERE 
    description LIKE 'referal_point_admin_%'
GROUP BY 
timestamp,
    user_id,
    change_amount, 
    description,
	balance_after_update,
    transaction_id
    limit $1 offset $2
`

type GetAddminAssignedPointsParams struct {
	Limit  int32
	Offset int32
}

type GetAddminAssignedPointsRow struct {
	UserID             uuid.NullUUID
	ChangeAmount       decimal.NullDecimal
	Timestamp          sql.NullTime
	Description        sql.NullString
	BalanceAfterUpdate decimal.Decimal
	TransactionID      string
	Total              int64
}

func (q *Queries) GetAddminAssignedPoints(ctx context.Context, arg GetAddminAssignedPointsParams) ([]GetAddminAssignedPointsRow, error) {
	rows, err := q.db.Query(ctx, getAddminAssignedPoints, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAddminAssignedPointsRow
	for rows.Next() {
		var i GetAddminAssignedPointsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ChangeAmount,
			&i.Timestamp,
			&i.Description,
			&i.BalanceAfterUpdate,
			&i.TransactionID,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdmins = `-- name: GetAdmins :many
WITH UserData AS (
    SELECT 
        us.id AS user_id,
        us.username,
        us.phone_number,
        us.profile,
        us.status,
        us.email,
        us.first_name,
        us.last_name,
        us.date_of_birth,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'role_id', r.id,
                'name', r.name
            ) ORDER BY us.created_at DESC
        ) AS roles
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
    JOIN roles r ON r.id = ur.role_id
    GROUP BY us.id, us.username, us.phone_number, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth
),
TotalCount AS (
    SELECT COUNT(*) AS total
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
)
SELECT 
    u.user_id, u.username, u.phone_number, u.profile, u.status, u.email, u.first_name, u.last_name, u.date_of_birth, u.roles,
    t.total
FROM UserData u
CROSS JOIN TotalCount t
ORDER BY u.user_id DESC
LIMIT $1
OFFSET $2
`

type GetAdminsParams struct {
	Limit  int32
	Offset int32
}

type GetAdminsRow struct {
	UserID      uuid.UUID
	Username    sql.NullString
	PhoneNumber sql.NullString
	Profile     sql.NullString
	Status      sql.NullString
	Email       sql.NullString
	FirstName   sql.NullString
	LastName    sql.NullString
	DateOfBirth sql.NullString
	Roles       pgtype.JSON
	Total       int64
}

func (q *Queries) GetAdmins(ctx context.Context, arg GetAdminsParams) ([]GetAdminsRow, error) {
	rows, err := q.db.Query(ctx, getAdmins, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsRow
	for rows.Next() {
		var i GetAdminsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.PhoneNumber,
			&i.Profile,
			&i.Status,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Roles,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminsByRole = `-- name: GetAdminsByRole :many
WITH admin_data AS (
    select ur.id, user_id, role_id, us.id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type from user_roles ur join users us on ur.user_id = us.id where role_id = $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM admin_data
)
SELECT c.id, c.user_id, c.role_id, c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, r.total_rows
FROM admin_data c
CROSS JOIN row_count r
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAdminsByRoleParams struct {
	RoleID uuid.UUID
	Limit  int32
	Offset int32
}

type GetAdminsByRoleRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	RoleID          uuid.UUID
	ID_2            uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetAdminsByRole(ctx context.Context, arg GetAdminsByRoleParams) ([]GetAdminsByRoleRow, error) {
	rows, err := q.db.Query(ctx, getAdminsByRole, arg.RoleID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsByRoleRow
	for rows.Next() {
		var i GetAdminsByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.ID_2,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminsByRoleAndStatus = `-- name: GetAdminsByRoleAndStatus :many
WITH admin_data AS (
    select ur.id, user_id, role_id, us.id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type from user_roles ur join users us on ur.user_id = us.id where role_id = $1 and status = $2 ),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM admin_data
)
SELECT c.id, c.user_id, c.role_id, c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, r.total_rows
FROM admin_data c
CROSS JOIN row_count r
ORDER BY c.created_at DESC
LIMIT $3 OFFSET $4
`

type GetAdminsByRoleAndStatusParams struct {
	RoleID uuid.UUID
	Status sql.NullString
	Limit  int32
	Offset int32
}

type GetAdminsByRoleAndStatusRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	RoleID          uuid.UUID
	ID_2            uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetAdminsByRoleAndStatus(ctx context.Context, arg GetAdminsByRoleAndStatusParams) ([]GetAdminsByRoleAndStatusRow, error) {
	rows, err := q.db.Query(ctx, getAdminsByRoleAndStatus,
		arg.RoleID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsByRoleAndStatusRow
	for rows.Next() {
		var i GetAdminsByRoleAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.ID_2,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminsByStatus = `-- name: GetAdminsByStatus :many
WITH UserData AS (
    SELECT 
        us.id AS user_id,
        us.username,
        us.phone_number,
        us.profile,
        us.status,
        us.email,
        us.first_name,
        us.last_name,
        us.date_of_birth,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'role_id', r.id,
                'name', r.name
            ) ORDER BY us.created_at DESC
        ) AS roles
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
    JOIN roles r ON r.id = ur.role_id where us.status = $1
    GROUP BY us.id, us.username, us.phone_number, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth
),
TotalCount AS (
    SELECT COUNT(*) AS total
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
)
SELECT 
    u.user_id, u.username, u.phone_number, u.profile, u.status, u.email, u.first_name, u.last_name, u.date_of_birth, u.roles,
    t.total
FROM UserData u
CROSS JOIN TotalCount t
ORDER BY u.user_id DESC
LIMIT $2
OFFSET $3
`

type GetAdminsByStatusParams struct {
	Status sql.NullString
	Limit  int32
	Offset int32
}

type GetAdminsByStatusRow struct {
	UserID      uuid.UUID
	Username    sql.NullString
	PhoneNumber sql.NullString
	Profile     sql.NullString
	Status      sql.NullString
	Email       sql.NullString
	FirstName   sql.NullString
	LastName    sql.NullString
	DateOfBirth sql.NullString
	Roles       pgtype.JSON
	Total       int64
}

func (q *Queries) GetAdminsByStatus(ctx context.Context, arg GetAdminsByStatusParams) ([]GetAdminsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAdminsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsByStatusRow
	for rows.Next() {
		var i GetAdminsByStatusRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.PhoneNumber,
			&i.Profile,
			&i.Status,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Roles,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
WITH users_data AS (
    SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
    FROM  users where default_currency  is not null
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM users_data
)
SELECT c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, r.total_rows
FROM users_data c
CROSS JOIN row_count r
ORDER BY c.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllUsersParams struct {
	Limit  int32
	Offset int32
}

type GetAllUsersRow struct {
	ID              uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOTP = `-- name: GetOTP :one
SELECT id, user_id, otp, created_at FROM users_otp where user_id = $1
`

func (q *Queries) GetOTP(ctx context.Context, userID uuid.UUID) (UsersOtp, error) {
	row := q.db.QueryRow(ctx, getOTP, userID)
	var i UsersOtp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Otp,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id,phone_number,email,first_name,last_name,date_of_birth,profile,default_currency,source,referal_code,street_address,country,state,city,postal_code,kyc_status,created_by,is_admin,status,password,referal_code,user_type,refered_by_code,referal_type FROM users where email = $1 or phone_number = $1
`

type GetUserByEmailRow struct {
	ID              uuid.UUID
	PhoneNumber     sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Profile         sql.NullString
	DefaultCurrency sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	Password        string
	ReferalCode_2   sql.NullString
	UserType        sql.NullString
	ReferedByCode   sql.NullString
	ReferalType     sql.NullString
}

func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.PhoneNumber,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Profile,
		&i.DefaultCurrency,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.Password,
		&i.ReferalCode_2,
		&i.UserType,
		&i.ReferedByCode,
		&i.ReferalType,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where phone_number = $1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phoneNumber sql.NullString) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserByReferalCode = `-- name: GetUserByReferalCode :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where referal_code  = $1
`

func (q *Queries) GetUserByReferalCode(ctx context.Context, referalCode sql.NullString) (User, error) {
	row := q.db.QueryRow(ctx, getUserByReferalCode, referalCode)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserByUserName = `-- name: GetUserByUserName :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where username = $1
`

func (q *Queries) GetUserByUserName(ctx context.Context, username sql.NullString) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUserName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserEmailOrPhoneNumber = `-- name: GetUserEmailOrPhoneNumber :many
WITH user_data AS (
    SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type,count(*) OVER() AS total_rows
    FROM users
    WHERE (phone_number ILIKE '%' || $1 || '%' OR $1 IS NULL)
      AND (email ILIKE '%' || $2 || '%' OR $2 IS NULL)
)
SELECT c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, c.total_rows FROM user_data c
ORDER BY c.created_at DESC
LIMIT $3 OFFSET $4
`

type GetUserEmailOrPhoneNumberParams struct {
	Column1 sql.NullString
	Column2 sql.NullString
	Limit   int32
	Offset  int32
}

type GetUserEmailOrPhoneNumberRow struct {
	ID              uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetUserEmailOrPhoneNumber(ctx context.Context, arg GetUserEmailOrPhoneNumberParams) ([]GetUserEmailOrPhoneNumberRow, error) {
	rows, err := q.db.Query(ctx, getUserEmailOrPhoneNumber,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEmailOrPhoneNumberRow
	for rows.Next() {
		var i GetUserEmailOrPhoneNumberRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPointsByReferals = `-- name: GetUserPointsByReferals :one
SELECT real_money,user_id from balances where user_id = (select id from users where referal_code = $1 limit 1) and currency = $2
`

type GetUserPointsByReferalsParams struct {
	ReferalCode sql.NullString
	Currency    string
}

type GetUserPointsByReferalsRow struct {
	RealMoney decimal.NullDecimal
	UserID    uuid.UUID
}

func (q *Queries) GetUserPointsByReferals(ctx context.Context, arg GetUserPointsByReferalsParams) (GetUserPointsByReferalsRow, error) {
	row := q.db.QueryRow(ctx, getUserPointsByReferals, arg.ReferalCode, arg.Currency)
	var i GetUserPointsByReferalsRow
	err := row.Scan(&i.RealMoney, &i.UserID)
	return i, err
}

const getUserReferalUsersByUserID = `-- name: GetUserReferalUsersByUserID :many
select description,change_amount,timestamp from balance_logs where user_id =$1 and currency = 'P'
`

type GetUserReferalUsersByUserIDRow struct {
	Description  sql.NullString
	ChangeAmount decimal.NullDecimal
	Timestamp    sql.NullTime
}

func (q *Queries) GetUserReferalUsersByUserID(ctx context.Context, userID uuid.NullUUID) ([]GetUserReferalUsersByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getUserReferalUsersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserReferalUsersByUserIDRow
	for rows.Next() {
		var i GetUserReferalUsersByUserIDRow
		if err := rows.Scan(&i.Description, &i.ChangeAmount, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByDepartmentNotificationTypes = `-- name: GetUsersByDepartmentNotificationTypes :many
SELECT us.id, us.username, us.phone_number, us.password, us.created_at, us.default_currency, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth, us.source, us.referal_code, us.street_address, us.country, us.state, us.city, us.postal_code, us.kyc_status, us.created_by, us.is_admin, us.status, us.referal_type, us.refered_by_code, us.user_type 
FROM users us
JOIN departements_users dus ON us.id = dus.user_id
JOIN departments dp ON dp.id = dus.department_id
WHERE $1::VARCHAR = ANY(dp.notifications)
`

func (q *Queries) GetUsersByDepartmentNotificationTypes(ctx context.Context, dollar_1 string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByDepartmentNotificationTypes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersDoseNotHaveReferalCode = `-- name: GetUsersDoseNotHaveReferalCode :many
select id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type from users where referal_code = ''
`

func (q *Queries) GetUsersDoseNotHaveReferalCode(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersDoseNotHaveReferalCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersInArrayOfUserIDs = `-- name: GetUsersInArrayOfUserIDs :many
SELECT username, created_at ,id
FROM users 
WHERE id = ANY($1::UUID[])
`

type GetUsersInArrayOfUserIDsRow struct {
	Username  sql.NullString
	CreatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) GetUsersInArrayOfUserIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]GetUsersInArrayOfUserIDsRow, error) {
	rows, err := q.db.Query(ctx, getUsersInArrayOfUserIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersInArrayOfUserIDsRow
	for rows.Next() {
		var i GetUsersInArrayOfUserIDsRow
		if err := rows.Scan(&i.Username, &i.CreatedAt, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveOTP = `-- name: SaveOTP :exec
INSERT INTO users_otp (user_id,otp,created_at)
VALUES ($1,$2,$3)
`

type SaveOTPParams struct {
	UserID    uuid.UUID
	Otp       string
	CreatedAt time.Time
}

func (q *Queries) SaveOTP(ctx context.Context, arg SaveOTPParams) error {
	_, err := q.db.Exec(ctx, saveOTP, arg.UserID, arg.Otp, arg.CreatedAt)
	return err
}

const updatePassword = `-- name: UpdatePassword :one
Update users set password = $1 where id = $2 RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

type UpdatePasswordParams struct {
	Password string
	ID       uuid.UUID
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updatePassword, arg.Password, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const updateProfile = `-- name: UpdateProfile :one
UPDATE users set first_name=$1,last_name = $2,email=$3,date_of_birth=$4,phone_number=$5,username = $6,street_address = $7,city = $8,postal_code = $9,state = $10,country = $11,kyc_status=$12 where id = $13
RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

type UpdateProfileParams struct {
	FirstName     sql.NullString
	LastName      sql.NullString
	Email         sql.NullString
	DateOfBirth   sql.NullString
	PhoneNumber   sql.NullString
	Username      sql.NullString
	StreetAddress string
	City          string
	PostalCode    string
	State         string
	Country       string
	KycStatus     string
	ID            uuid.UUID
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateProfile,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.DateOfBirth,
		arg.PhoneNumber,
		arg.Username,
		arg.StreetAddress,
		arg.City,
		arg.PostalCode,
		arg.State,
		arg.Country,
		arg.KycStatus,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const updateProfilePicuter = `-- name: UpdateProfilePicuter :one
UPDATE users set profile = $1  where id = $2 RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

type UpdateProfilePicuterParams struct {
	Profile sql.NullString
	ID      uuid.UUID
}

func (q *Queries) UpdateProfilePicuter(ctx context.Context, arg UpdateProfilePicuterParams) (User, error) {
	row := q.db.QueryRow(ctx, updateProfilePicuter, arg.Profile, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

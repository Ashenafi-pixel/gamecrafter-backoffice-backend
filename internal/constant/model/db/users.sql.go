// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
	"github.com/lib/pq"
	"github.com/shopspring/decimal"
)

const addReferalCode = `-- name: AddReferalCode :exec
UPDATE users set referal_code = $1 where id = $2
`

type AddReferalCodeParams struct {
	ReferalCode sql.NullString
	ID          uuid.UUID
}

func (q *Queries) AddReferalCode(ctx context.Context, arg AddReferalCodeParams) error {
	_, err := q.db.Exec(ctx, addReferalCode, arg.ReferalCode, arg.ID)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username,phone_number,password,default_currency,email,source,referal_code,date_of_birth,created_by,is_admin,first_name,last_name,referal_type,refered_by_code,user_type,status,is_test_account) 
values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17) RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, user_type, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, refered_by_code, referal_type, is_test_account
`

type CreateUserParams struct {
	Username        string
	PhoneNumber     sql.NullString
	Password        string
	DefaultCurrency sql.NullString
	Email           sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	DateOfBirth     sql.NullString
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	FirstName       sql.NullString
	LastName        sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	Status          sql.NullString
	IsTestAccount   sql.NullBool
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.PhoneNumber,
		arg.Password,
		arg.DefaultCurrency,
		arg.Email,
		arg.Source,
		arg.ReferalCode,
		arg.DateOfBirth,
		arg.CreatedBy,
		arg.IsAdmin,
		arg.FirstName,
		arg.LastName,
		arg.ReferalType,
		arg.ReferedByCode,
		arg.UserType,
		arg.Status,
		arg.IsTestAccount,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.UserType,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferedByCode,
		&i.ReferalType,
		&i.IsTestAccount,
	)
	return i, err
}

const deleteOTP = `-- name: DeleteOTP :exec
DELETE from users_otp where user_id = $1
`

func (q *Queries) DeleteOTP(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOTP, userID)
	return err
}

const getAddminAssignedPoints = `-- name: GetAddminAssignedPoints :many
SELECT 
    user_id,
    change_amount,
    timestamp,
    description,
	balance_after_update,
    transaction_id,
    COUNT(id) AS total
FROM 
    balance_logs
WHERE 
    description LIKE 'referal_point_admin_%'
GROUP BY 
timestamp,
    user_id,
    change_amount, 
    description,
	balance_after_update,
    transaction_id
    limit $1 offset $2
`

type GetAddminAssignedPointsParams struct {
	Limit  int32
	Offset int32
}

type GetAddminAssignedPointsRow struct {
	UserID             uuid.NullUUID
	ChangeAmount       decimal.NullDecimal
	Timestamp          sql.NullTime
	Description        sql.NullString
	BalanceAfterUpdate decimal.Decimal
	TransactionID      string
	Total              int64
}

func (q *Queries) GetAddminAssignedPoints(ctx context.Context, arg GetAddminAssignedPointsParams) ([]GetAddminAssignedPointsRow, error) {
	rows, err := q.db.Query(ctx, getAddminAssignedPoints, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAddminAssignedPointsRow
	for rows.Next() {
		var i GetAddminAssignedPointsRow
		if err := rows.Scan(
			&i.UserID,
			&i.ChangeAmount,
			&i.Timestamp,
			&i.Description,
			&i.BalanceAfterUpdate,
			&i.TransactionID,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdmins = `-- name: GetAdmins :many
WITH UserData AS (
    SELECT 
        us.id AS user_id,
        us.username,
        us.phone_number,
        us.profile,
        us.status,
        us.email,
        us.first_name,
        us.last_name,
        us.date_of_birth,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'role_id', r.id,
                'name', r.name
            ) ORDER BY us.created_at DESC
        ) AS roles
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
    JOIN roles r ON r.id = ur.role_id
    GROUP BY us.id, us.username, us.phone_number, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth
),
TotalCount AS (
    SELECT COUNT(*) AS total
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
)
SELECT 
    u.user_id, u.username, u.phone_number, u.profile, u.status, u.email, u.first_name, u.last_name, u.date_of_birth, u.roles,
    t.total
FROM UserData u
CROSS JOIN TotalCount t
ORDER BY u.user_id DESC
LIMIT $1
OFFSET $2
`

type GetAdminsParams struct {
	Limit  int32
	Offset int32
}

type GetAdminsRow struct {
	UserID      uuid.UUID
	Username    sql.NullString
	PhoneNumber sql.NullString
	Profile     sql.NullString
	Status      sql.NullString
	Email       sql.NullString
	FirstName   sql.NullString
	LastName    sql.NullString
	DateOfBirth sql.NullString
	Roles       pgtype.JSON
	Total       int64
}

func (q *Queries) GetAdmins(ctx context.Context, arg GetAdminsParams) ([]GetAdminsRow, error) {
	rows, err := q.db.Query(ctx, getAdmins, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsRow
	for rows.Next() {
		var i GetAdminsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.PhoneNumber,
			&i.Profile,
			&i.Status,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Roles,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminsByRole = `-- name: GetAdminsByRole :many
WITH admin_data AS (
    select ur.id, user_id, role_id, us.id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type from user_roles ur join users us on ur.user_id = us.id where role_id = $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM admin_data
)
SELECT c.id, c.user_id, c.role_id, c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, r.total_rows
FROM admin_data c
CROSS JOIN row_count r
ORDER BY c.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAdminsByRoleParams struct {
	RoleID uuid.UUID
	Limit  int32
	Offset int32
}

type GetAdminsByRoleRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	RoleID          uuid.UUID
	ID_2            uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetAdminsByRole(ctx context.Context, arg GetAdminsByRoleParams) ([]GetAdminsByRoleRow, error) {
	rows, err := q.db.Query(ctx, getAdminsByRole, arg.RoleID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsByRoleRow
	for rows.Next() {
		var i GetAdminsByRoleRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.ID_2,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminsByRoleAndStatus = `-- name: GetAdminsByRoleAndStatus :many
WITH admin_data AS (
    select ur.id, user_id, role_id, us.id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type from user_roles ur join users us on ur.user_id = us.id where role_id = $1 and status = $2 ),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM admin_data
)
SELECT c.id, c.user_id, c.role_id, c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, r.total_rows
FROM admin_data c
CROSS JOIN row_count r
ORDER BY c.created_at DESC
LIMIT $3 OFFSET $4
`

type GetAdminsByRoleAndStatusParams struct {
	RoleID uuid.UUID
	Status sql.NullString
	Limit  int32
	Offset int32
}

type GetAdminsByRoleAndStatusRow struct {
	ID              uuid.UUID
	UserID          uuid.UUID
	RoleID          uuid.UUID
	ID_2            uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetAdminsByRoleAndStatus(ctx context.Context, arg GetAdminsByRoleAndStatusParams) ([]GetAdminsByRoleAndStatusRow, error) {
	rows, err := q.db.Query(ctx, getAdminsByRoleAndStatus,
		arg.RoleID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsByRoleAndStatusRow
	for rows.Next() {
		var i GetAdminsByRoleAndStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoleID,
			&i.ID_2,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminsByStatus = `-- name: GetAdminsByStatus :many
WITH UserData AS (
    SELECT 
        us.id AS user_id,
        us.username,
        us.phone_number,
        us.profile,
        us.status,
        us.email,
        us.first_name,
        us.last_name,
        us.date_of_birth,
        JSON_AGG(
            JSON_BUILD_OBJECT(
                'role_id', r.id,
                'name', r.name
            ) ORDER BY us.created_at DESC
        ) AS roles
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
    JOIN roles r ON r.id = ur.role_id where us.status = $1
    GROUP BY us.id, us.username, us.phone_number, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth
),
TotalCount AS (
    SELECT COUNT(*) AS total
    FROM users us
    JOIN user_roles ur ON ur.user_id = us.id
)
SELECT 
    u.user_id, u.username, u.phone_number, u.profile, u.status, u.email, u.first_name, u.last_name, u.date_of_birth, u.roles,
    t.total
FROM UserData u
CROSS JOIN TotalCount t
ORDER BY u.user_id DESC
LIMIT $2
OFFSET $3
`

type GetAdminsByStatusParams struct {
	Status sql.NullString
	Limit  int32
	Offset int32
}

type GetAdminsByStatusRow struct {
	UserID      uuid.UUID
	Username    sql.NullString
	PhoneNumber sql.NullString
	Profile     sql.NullString
	Status      sql.NullString
	Email       sql.NullString
	FirstName   sql.NullString
	LastName    sql.NullString
	DateOfBirth sql.NullString
	Roles       pgtype.JSON
	Total       int64
}

func (q *Queries) GetAdminsByStatus(ctx context.Context, arg GetAdminsByStatusParams) ([]GetAdminsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getAdminsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsByStatusRow
	for rows.Next() {
		var i GetAdminsByStatusRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.PhoneNumber,
			&i.Profile,
			&i.Status,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Roles,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
WITH users_data AS (
    SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
    FROM  users where default_currency  is not null AND user_type = 'PLAYER'
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM users_data
)
SELECT c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, r.total_rows
FROM users_data c
CROSS JOIN row_count r
ORDER BY c.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllUsersParams struct {
	Limit  int32
	Offset int32
}

type GetAllUsersRow struct {
	ID              uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]GetAllUsersRow, error) {
	rows, err := q.db.Query(ctx, getAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersRow
	for rows.Next() {
		var i GetAllUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOTP = `-- name: GetOTP :one
SELECT id, user_id, otp, created_at FROM users_otp where user_id = $1
`

func (q *Queries) GetOTP(ctx context.Context, userID uuid.UUID) (UsersOtp, error) {
	row := q.db.QueryRow(ctx, getOTP, userID)
	var i UsersOtp
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Otp,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, is_email_verified, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type, primary_wallet_address, wallet_verification_status FROM users where email = $1
`

type GetUserByEmailRow struct {
	ID                       uuid.UUID
	Username                 sql.NullString
	PhoneNumber              sql.NullString
	Password                 string
	CreatedAt                time.Time
	DefaultCurrency          sql.NullString
	Profile                  sql.NullString
	Email                    sql.NullString
	FirstName                sql.NullString
	LastName                 sql.NullString
	DateOfBirth              sql.NullString
	Source                   sql.NullString
	IsEmailVerified          sql.NullBool
	ReferalCode              sql.NullString
	StreetAddress            sql.NullString
	Country                  sql.NullString
	State                    sql.NullString
	City                     sql.NullString
	PostalCode               sql.NullString
	KycStatus                sql.NullString
	CreatedBy                uuid.NullUUID
	IsAdmin                  sql.NullBool
	Status                   sql.NullString
	ReferalType              sql.NullString
	ReferedByCode            sql.NullString
	UserType                 sql.NullString
	PrimaryWalletAddress     sql.NullString
	WalletVerificationStatus sql.NullString
}

func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (bool, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.IsEmailVerified,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
		&i.PrimaryWalletAddress,
		&i.WalletVerificationStatus,
	)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return false, nil
		}
		return false, err
	}
	return true, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserByPhone = `-- name: GetUserByPhone :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where phone_number = $1
`

func (q *Queries) GetUserByPhone(ctx context.Context, phoneNumber sql.NullString) (User, error) {
	row := q.db.QueryRow(ctx, getUserByPhone, phoneNumber)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserByReferalCode = `-- name: GetUserByReferalCode :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where referal_code  = $1
`

func (q *Queries) GetUserByReferalCode(ctx context.Context, referalCode sql.NullString) (User, error) {
	row := q.db.QueryRow(ctx, getUserByReferalCode, referalCode)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserByUserName = `-- name: GetUserByUserName :one
SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type FROM users where username = $1
`

func (q *Queries) GetUserByUserName(ctx context.Context, username sql.NullString) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUserName, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getUserEmailOrPhoneNumber = `-- name: GetUserEmailOrPhoneNumber :many
WITH user_data AS (
    SELECT id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type,count(*) OVER() AS total_rows
    FROM users
    WHERE (phone_number ILIKE '%' || $1 || '%' OR $1 IS NULL)
      AND (email ILIKE '%' || $2 || '%' OR $2 IS NULL)
)
SELECT c.id, c.username, c.phone_number, c.password, c.created_at, c.default_currency, c.profile, c.email, c.first_name, c.last_name, c.date_of_birth, c.source, c.referal_code, c.street_address, c.country, c.state, c.city, c.postal_code, c.kyc_status, c.created_by, c.is_admin, c.status, c.referal_type, c.refered_by_code, c.user_type, c.total_rows FROM user_data c
ORDER BY c.created_at DESC
LIMIT $3 OFFSET $4
`

type GetUserEmailOrPhoneNumberParams struct {
	Column1 sql.NullString
	Column2 sql.NullString
	Limit   int32
	Offset  int32
}

type GetUserEmailOrPhoneNumberRow struct {
	ID              uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt       time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy       uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	TotalRows       int64
}

func (q *Queries) GetUserEmailOrPhoneNumber(ctx context.Context, arg GetUserEmailOrPhoneNumberParams) ([]GetUserEmailOrPhoneNumberRow, error) {
	rows, err := q.db.Query(ctx, getUserEmailOrPhoneNumber,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEmailOrPhoneNumberRow
	for rows.Next() {
		var i GetUserEmailOrPhoneNumberRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPointsByReferals = `-- name: GetUserPointsByReferals :one
SELECT amount_units,user_id from balances where user_id = (select id from users where referal_code = $1 limit 1) and currency = $2
`

type GetUserPointsByReferalsParams struct {
	ReferalCode sql.NullString
	Currency    string
}

type GetUserPointsByReferalsRow struct {
	AmountUnits decimal.Decimal
	UserID      uuid.UUID
}

func (q *Queries) GetUserPointsByReferals(ctx context.Context, arg GetUserPointsByReferalsParams) (GetUserPointsByReferalsRow, error) {
	row := q.db.QueryRow(ctx, getUserPointsByReferals, arg.ReferalCode, arg.Currency)
	var i GetUserPointsByReferalsRow
	err := row.Scan(&i.AmountUnits, &i.UserID)
	return i, err
}

const getUserReferalUsersByUserID = `-- name: GetUserReferalUsersByUserID :many
select description,change_amount,timestamp from balance_logs where user_id =$1 and currency = 'P'
`

type GetUserReferalUsersByUserIDRow struct {
	Description  sql.NullString
	ChangeAmount decimal.NullDecimal
	Timestamp    sql.NullTime
}

func (q *Queries) GetUserReferalUsersByUserID(ctx context.Context, userID uuid.NullUUID) ([]GetUserReferalUsersByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getUserReferalUsersByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserReferalUsersByUserIDRow
	for rows.Next() {
		var i GetUserReferalUsersByUserIDRow
		if err := rows.Scan(&i.Description, &i.ChangeAmount, &i.Timestamp); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByDepartmentNotificationTypes = `-- name: GetUsersByDepartmentNotificationTypes :many
SELECT us.id, us.username, us.phone_number, us.password, us.created_at, us.default_currency, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth, us.source, us.referal_code, us.street_address, us.country, us.state, us.city, us.postal_code, us.kyc_status, us.created_by, us.is_admin, us.status, us.referal_type, us.refered_by_code, us.user_type 
FROM users us
JOIN departements_users dus ON us.id = dus.user_id
JOIN departments dp ON dp.id = dus.department_id
WHERE $1::VARCHAR = ANY(dp.notifications)
`

func (q *Queries) GetUsersByDepartmentNotificationTypes(ctx context.Context, dollar_1 string) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersByDepartmentNotificationTypes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersDoseNotHaveReferalCode = `-- name: GetUsersDoseNotHaveReferalCode :many
select id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type from users where referal_code = ''
`

func (q *Queries) GetUsersDoseNotHaveReferalCode(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getUsersDoseNotHaveReferalCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersInArrayOfUserIDs = `-- name: GetUsersInArrayOfUserIDs :many
SELECT username, created_at ,id
FROM users 
WHERE id = ANY($1::UUID[])
`

type GetUsersInArrayOfUserIDsRow struct {
	Username  sql.NullString
	CreatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) GetUsersInArrayOfUserIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]GetUsersInArrayOfUserIDsRow, error) {
	rows, err := q.db.Query(ctx, getUsersInArrayOfUserIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersInArrayOfUserIDsRow
	for rows.Next() {
		var i GetUsersInArrayOfUserIDsRow
		if err := rows.Scan(&i.Username, &i.CreatedAt, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveOTP = `-- name: SaveOTP :exec
INSERT INTO users_otp (user_id,otp,created_at)
VALUES ($1,$2,$3)
`

type SaveOTPParams struct {
	UserID    uuid.UUID
	Otp       string
	CreatedAt time.Time
}

func (q *Queries) SaveOTP(ctx context.Context, arg SaveOTPParams) error {
	_, err := q.db.Exec(ctx, saveOTP, arg.UserID, arg.Otp, arg.CreatedAt)
	return err
}

const updatePassword = `-- name: UpdatePassword :one
Update users set password = $1 where id = $2 RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

const updateUser = `-- name: UpdateUser :one
UPDATE users SET 
    username = $2,
    email = $3,
    phone_number = $4,
    first_name = $5,
    last_name = $6,
    status = $7,
    is_admin = $8,
    user_type = $9,
    updated_at = $10
WHERE id = $1
RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

const updateUserPassword = `-- name: UpdateUserPassword :one
UPDATE users SET password = $2 WHERE id = $1
RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1
`

type UpdatePasswordParams struct {
	Password string
	ID       uuid.UUID
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updatePassword, arg.Password, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

type UpdateUserParams struct {
	ID          uuid.UUID
	Username    sql.NullString
	Email       sql.NullString
	PhoneNumber sql.NullString
	FirstName   sql.NullString
	LastName    sql.NullString
	Status      sql.NullString
	IsAdmin     sql.NullBool
	UserType    sql.NullString
	UpdatedAt   time.Time
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Username,
		arg.Email,
		arg.PhoneNumber,
		arg.FirstName,
		arg.LastName,
		arg.Status,
		arg.IsAdmin,
		arg.UserType,
		arg.UpdatedAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

type UpdateUserPasswordParams struct {
	ID       uuid.UUID
	Password string
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserPassword, arg.ID, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const updateProfile = `-- name: UpdateProfile :one
UPDATE users set first_name=$1,last_name = $2,email=$3,date_of_birth=$4,phone_number=$5,username = $6,street_address = $7,city = $8,postal_code = $9,state = $10,country = $11,kyc_status=$12,status=$13,is_email_verified=$14,default_currency=$15,wallet_verification_status=$16,is_test_account=$18 where id = $17
RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type, is_email_verified, wallet_verification_status, is_test_account
`

type UpdateProfileParams struct {
	FirstName                sql.NullString
	LastName                 sql.NullString
	Email                    sql.NullString
	DateOfBirth              sql.NullString
	PhoneNumber              sql.NullString
	Username                 sql.NullString
	StreetAddress            string
	City                     string
	PostalCode               string
	State                    string
	Country                  string
	KycStatus                string
	Status                   string
	IsEmailVerified          bool
	DefaultCurrency          string
	WalletVerificationStatus string
	ID                       uuid.UUID
	IsTestAccount            sql.NullBool
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateProfile,
		arg.FirstName,
		arg.LastName,
		arg.Email,
		arg.DateOfBirth,
		arg.PhoneNumber,
		arg.Username,
		arg.StreetAddress,
		arg.City,
		arg.PostalCode,
		arg.State,
		arg.Country,
		arg.KycStatus,
		arg.Status,
		arg.IsEmailVerified,
		arg.DefaultCurrency,
		arg.WalletVerificationStatus,
		arg.ID,
		arg.IsTestAccount,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
		&i.IsEmailVerified,
		&i.WalletVerificationStatus,
		&i.IsTestAccount,
	)
	return i, err
}

const updateProfilePicuter = `-- name: UpdateProfilePicuter :one
UPDATE users set profile = $1  where id = $2 RETURNING id, username, phone_number, password, created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, created_by, is_admin, status, referal_type, refered_by_code, user_type
`

type UpdateProfilePicuterParams struct {
	Profile sql.NullString
	ID      uuid.UUID
}

func (q *Queries) UpdateProfilePicuter(ctx context.Context, arg UpdateProfilePicuterParams) (User, error) {
	row := q.db.QueryRow(ctx, updateProfilePicuter, arg.Profile, arg.ID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PhoneNumber,
		&i.Password,
		&i.CreatedAt,
		&i.DefaultCurrency,
		&i.Profile,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Source,
		&i.ReferalCode,
		&i.StreetAddress,
		&i.Country,
		&i.State,
		&i.City,
		&i.PostalCode,
		&i.KycStatus,
		&i.CreatedBy,
		&i.IsAdmin,
		&i.Status,
		&i.ReferalType,
		&i.ReferedByCode,
		&i.UserType,
	)
	return i, err
}

const getAllUsersWithFilters = `-- name: GetAllUsersWithFilters :many 
WITH users_data AS (
    SELECT u.*, COALESCE(SUM(b.amount_units), 0) as total_balance
    FROM users u
    LEFT JOIN balances b ON u.id = b.user_id
    WHERE u.default_currency IS NOT NULL 
    AND u.user_type = 'PLAYER'
    AND u.is_admin = false
    AND (
        -- Search across all fields using contains (ILIKE) match
        ($1::text IS NULL OR $1 = '' OR $1 = '%%' OR 
         (u.username IS NOT NULL AND u.username ILIKE '%' || $1 || '%') OR 
         (u.email IS NOT NULL AND u.email ILIKE '%' || $1 || '%') OR 
         (u.phone_number IS NOT NULL AND u.phone_number ILIKE '%' || $1 || '%') OR 
         (u.id::text ILIKE '%' || $1 || '%'))
    )
    AND ($2::text[] IS NULL OR array_length($2, 1) IS NULL OR array_length($2, 1) = 0 OR u.status = ANY($2))
    AND ($3::text[] IS NULL OR array_length($3, 1) IS NULL OR array_length($3, 1) = 0 OR u.kyc_status = ANY($3))
    AND ($4::boolean IS NULL OR u.is_test_account = $4)
    AND ($5::uuid[] IS NULL OR array_length($5, 1) IS NULL OR array_length($5, 1) = 0 OR u.brand_id = ANY($5))
    AND ($10::text IS NULL OR $10 = '' OR u.refered_by_code = $10)
    GROUP BY u.id
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM users_data
)
SELECT 
    c.id,
    c.username,
    c.phone_number,
    c.password,
    c.created_at,
    c.default_currency,
    c.profile,
    c.email,
    c.first_name,
    c.last_name,
    c.date_of_birth,
    c.source,
    c.is_email_verified,
    c.referal_code,
    c.street_address,
    c.country,
    c.state,
    c.city,
    c.postal_code,
    c.kyc_status,
    c.created_by,
    c.is_admin,
    c.status,
    c.referal_type,
    c.refered_by_code,
    c.user_type,
    c.primary_wallet_address,
    c.wallet_verification_status,
    c.is_test_account,
    c.two_factor_enabled,
    c.two_factor_setup_at,
    c.total_balance,
    r.total_rows
FROM users_data c
CROSS JOIN row_count r
ORDER BY 
  CASE WHEN $6::text = 'username' AND $7::text = 'asc' THEN c.username END ASC NULLS LAST,
  CASE WHEN $6::text = 'username' AND $7::text = 'desc' THEN c.username END DESC NULLS LAST,
  CASE WHEN $6::text = 'email' AND $7::text = 'asc' THEN c.email END ASC NULLS LAST,
  CASE WHEN $6::text = 'email' AND $7::text = 'desc' THEN c.email END DESC NULLS LAST,
  CASE WHEN $6::text = 'balance' AND $7::text = 'asc' THEN c.total_balance END ASC NULLS LAST,
  CASE WHEN $6::text = 'balance' AND $7::text = 'desc' THEN c.total_balance END DESC NULLS LAST,
  CASE WHEN $6::text = 'created_at' AND $7::text = 'asc' THEN c.created_at END ASC NULLS LAST,
  CASE WHEN $6::text = 'created_at' AND $7::text = 'desc' THEN c.created_at END DESC NULLS LAST,
  c.created_at DESC
LIMIT $8 OFFSET $9
`

type GetAllUsersWithFiltersParams struct {
	SearchTerm    sql.NullString
	Status        []string
	KycStatus     []string
	Limit         int32
	Offset        int32
	IsTestAccount sql.NullBool
	BrandID       []uuid.UUID
	SortBy        sql.NullString
	SortOrder     sql.NullString
	ReferedByCode sql.NullString
}

type GetAllUsersWithFiltersRow struct {
	ID                       uuid.UUID
	Username                 sql.NullString
	PhoneNumber              sql.NullString
	Password                 string
	CreatedAt                time.Time
	DefaultCurrency          sql.NullString
	Profile                  sql.NullString
	Email                    sql.NullString
	FirstName                sql.NullString
	LastName                 sql.NullString
	DateOfBirth              sql.NullString
	Source                   sql.NullString
	IsEmailVerified          sql.NullBool
	ReferalCode              sql.NullString
	StreetAddress            string
	Country                  string
	State                    string
	City                     string
	PostalCode               string
	KycStatus                string
	CreatedBy                uuid.NullUUID
	IsAdmin                  sql.NullBool
	Status                   sql.NullString
	ReferalType              sql.NullString
	ReferedByCode            sql.NullString
	UserType                 sql.NullString
	PrimaryWalletAddress     sql.NullString
	WalletVerificationStatus sql.NullString
	IsTestAccount            sql.NullBool
	TwoFactorEnabled         sql.NullBool
	TwoFactorSetupAt         sql.NullTime
	TotalRows                int64
}

func (q *Queries) GetAllUsersWithFilters(ctx context.Context, arg GetAllUsersWithFiltersParams) ([]GetAllUsersWithFiltersRow, error) {
	var brandIDArray interface{}
	if len(arg.BrandID) > 0 {
		brandIDArray = pq.Array(arg.BrandID)
	}
	rows, err := q.db.Query(ctx, getAllUsersWithFilters,
		arg.SearchTerm,
		pq.Array(arg.Status),
		pq.Array(arg.KycStatus),
		arg.IsTestAccount,
		brandIDArray,
		arg.SortBy,
		arg.SortOrder,
		arg.Limit,
		arg.Offset,
		arg.ReferedByCode,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUsersWithFiltersRow
	for rows.Next() {
		var i GetAllUsersWithFiltersRow
		var totalBalance sql.NullString // Temporary variable for total_balance (used only for sorting)
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.IsEmailVerified,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.PrimaryWalletAddress,
			&i.WalletVerificationStatus,
			&i.IsTestAccount,
			&i.TwoFactorEnabled,
			&i.TwoFactorSetupAt,
			&totalBalance, // Scan total_balance but don't use it
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAdminUsers = `-- name: GetAdminUsers :many
WITH admin_users AS (
    SELECT 
        us.id AS user_id,
        us.username,
        us.phone_number,
        us.profile,
        us.status,
        us.email,
        us.first_name,
        us.last_name,
        us.date_of_birth,
        us.created_at,
        us.updated_at,
        us.last_login,
        us.is_admin,
        us.user_type,
        COALESCE(
            JSON_AGG(
                JSON_BUILD_OBJECT(
                    'role_id', r.id,
                    'name', r.name
                )
            ) FILTER (WHERE r.id IS NOT NULL),
            '[]'::json
        ) AS roles,
        COUNT(*) OVER() AS total_rows
    FROM users us
    LEFT JOIN user_roles ur ON ur.user_id = us.id
    LEFT JOIN roles r ON r.id = ur.role_id
    WHERE us.is_admin = true OR us.user_type = 'ADMIN'
    GROUP BY us.id, us.username, us.phone_number, us.profile, us.status, us.email, us.first_name, us.last_name, us.date_of_birth, us.created_at, us.updated_at, us.last_login, us.is_admin, us.user_type
)
SELECT 
    au.user_id,
    au.username,
    au.phone_number,
    au.profile,
    au.status,
    au.email,
    au.first_name,
    au.last_name,
    au.date_of_birth,
    au.created_at,
    au.updated_at,
    au.last_login,
    au.is_admin,
    au.user_type,
    au.roles,
    au.total_rows
FROM admin_users au
ORDER BY au.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAdminUsersParams struct {
	Limit  int32
	Offset int32
}

type GetAdminUsersRow struct {
	UserID                   uuid.UUID
	Username                 sql.NullString
	PhoneNumber              sql.NullString
	Profile                  sql.NullString
	Status                   sql.NullString
	Email                    sql.NullString
	FirstName                sql.NullString
	LastName                 sql.NullString
	DateOfBirth              sql.NullString
	StreetAddress            sql.NullString
	City                     sql.NullString
	PostalCode               sql.NullString
	State                    sql.NullString
	Country                  sql.NullString
	KycStatus                sql.NullString
	IsEmailVerified          sql.NullBool
	DefaultCurrency          sql.NullString
	WalletVerificationStatus sql.NullString
	CreatedAt                time.Time
	IsAdmin                  sql.NullBool
	UserType                 sql.NullString
	Roles                    pgtype.JSON
	TotalRows                int64
}

func (q *Queries) GetAdminUsers(ctx context.Context, arg GetAdminUsersParams) ([]GetAdminUsersRow, error) {
	rows, err := q.db.Query(ctx, getAdminUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminUsersRow
	for rows.Next() {
		var i GetAdminUsersRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.PhoneNumber,
			&i.Profile,
			&i.Status,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.StreetAddress,
			&i.City,
			&i.PostalCode,
			&i.State,
			&i.Country,
			&i.KycStatus,
			&i.IsEmailVerified,
			&i.DefaultCurrency,
			&i.WalletVerificationStatus,
			&i.CreatedAt,
			&i.IsAdmin,
			&i.UserType,
			&i.Roles,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

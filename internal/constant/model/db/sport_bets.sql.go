// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sport_bets.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
	"github.com/shopspring/decimal"
)

const createSportBet = `-- name: CreateSportBet :one

INSERT INTO sport_bets (
    transaction_id, bet_amount, bet_reference_num, game_reference, bet_mode, 
    description, frontend_type, sport_ids, site_id, 
    client_ip, autorecharge, bet_details, user_id, currency, 
    potential_win, actual_win, odds,status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17,$18
) ON CONFLICT (transaction_id) DO UPDATE SET
    bet_amount = EXCLUDED.bet_amount,
    bet_reference_num = EXCLUDED.bet_reference_num,
    game_reference = EXCLUDED.game_reference,
    bet_mode = EXCLUDED.bet_mode,
    description = EXCLUDED.description,
    frontend_type = EXCLUDED.frontend_type,
    sport_ids = EXCLUDED.sport_ids,
    site_id = EXCLUDED.site_id,
    client_ip = EXCLUDED.client_ip,
    autorecharge = EXCLUDED.autorecharge,
    bet_details = EXCLUDED.bet_details,
    user_id = EXCLUDED.user_id,
    currency = EXCLUDED.currency,
    potential_win = EXCLUDED.potential_win,
    actual_win = EXCLUDED.actual_win,
    odds = EXCLUDED.odds,
    status=EXCLUDED.status,
    updated_at = NOW()
RETURNING id, transaction_id, bet_amount, bet_reference_num, game_reference, bet_mode, description, user_id, frontend_type, status, sport_ids, site_id, client_ip, affiliate_user_id, autorecharge, bet_details, currency, potential_win, actual_win, odds, placed_at, settled_at, created_at, updated_at
`

type CreateSportBetParams struct {
	TransactionID   string
	BetAmount       decimal.Decimal
	BetReferenceNum string
	GameReference   string
	BetMode         string
	Description     sql.NullString
	FrontendType    sql.NullString
	SportIds        sql.NullString
	SiteID          string
	ClientIp        sql.NullString
	Autorecharge    sql.NullString
	BetDetails      pgtype.JSONB
	UserID          uuid.UUID
	Currency        string
	PotentialWin    decimal.NullDecimal
	ActualWin       decimal.NullDecimal
	Odds            decimal.NullDecimal
	Status          sql.NullString
}

// Sport Bets Queries based on PlaceBetRequest DTO
func (q *Queries) CreateSportBet(ctx context.Context, arg CreateSportBetParams) (SportBet, error) {
	row := q.db.QueryRow(ctx, createSportBet,
		arg.TransactionID,
		arg.BetAmount,
		arg.BetReferenceNum,
		arg.GameReference,
		arg.BetMode,
		arg.Description,
		arg.FrontendType,
		arg.SportIds,
		arg.SiteID,
		arg.ClientIp,
		arg.Autorecharge,
		arg.BetDetails,
		arg.UserID,
		arg.Currency,
		arg.PotentialWin,
		arg.ActualWin,
		arg.Odds,
		arg.Status,
	)
	var i SportBet
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.BetAmount,
		&i.BetReferenceNum,
		&i.GameReference,
		&i.BetMode,
		&i.Description,
		&i.UserID,
		&i.FrontendType,
		&i.Status,
		&i.SportIds,
		&i.SiteID,
		&i.ClientIp,
		&i.AffiliateUserID,
		&i.Autorecharge,
		&i.BetDetails,
		&i.Currency,
		&i.PotentialWin,
		&i.ActualWin,
		&i.Odds,
		&i.PlacedAt,
		&i.SettledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSportBet = `-- name: GetSportBet :one
SELECT id, transaction_id, bet_amount, bet_reference_num, game_reference, bet_mode, description, user_id, frontend_type, status, sport_ids, site_id, client_ip, affiliate_user_id, autorecharge, bet_details, currency, potential_win, actual_win, odds, placed_at, settled_at, created_at, updated_at FROM sport_bets WHERE transaction_id = $1
`

func (q *Queries) GetSportBet(ctx context.Context, transactionID string) (SportBet, error) {
	row := q.db.QueryRow(ctx, getSportBet, transactionID)
	var i SportBet
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.BetAmount,
		&i.BetReferenceNum,
		&i.GameReference,
		&i.BetMode,
		&i.Description,
		&i.UserID,
		&i.FrontendType,
		&i.Status,
		&i.SportIds,
		&i.SiteID,
		&i.ClientIp,
		&i.AffiliateUserID,
		&i.Autorecharge,
		&i.BetDetails,
		&i.Currency,
		&i.PotentialWin,
		&i.ActualWin,
		&i.Odds,
		&i.PlacedAt,
		&i.SettledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listSportBets = `-- name: ListSportBets :many
SELECT id, transaction_id, bet_amount, bet_reference_num, game_reference, bet_mode, description, user_id, frontend_type, status, sport_ids, site_id, client_ip, affiliate_user_id, autorecharge, bet_details, currency, potential_win, actual_win, odds, placed_at, settled_at, created_at, updated_at FROM sport_bets 
WHERE user_id = $1 
ORDER BY placed_at DESC 
LIMIT $2 OFFSET $3
`

type ListSportBetsParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) ListSportBets(ctx context.Context, arg ListSportBetsParams) ([]SportBet, error) {
	rows, err := q.db.Query(ctx, listSportBets, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SportBet
	for rows.Next() {
		var i SportBet
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.BetAmount,
			&i.BetReferenceNum,
			&i.GameReference,
			&i.BetMode,
			&i.Description,
			&i.UserID,
			&i.FrontendType,
			&i.Status,
			&i.SportIds,
			&i.SiteID,
			&i.ClientIp,
			&i.AffiliateUserID,
			&i.Autorecharge,
			&i.BetDetails,
			&i.Currency,
			&i.PotentialWin,
			&i.ActualWin,
			&i.Odds,
			&i.PlacedAt,
			&i.SettledAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSportBetStatus = `-- name: UpdateSportBetStatus :one
UPDATE sport_bets 
SET status = $2, 
    actual_win = $3, 
    settled_at = NOW(),
    updated_at = NOW()
WHERE transaction_id = $1 and user_id =$2 and settled_at is null
RETURNING id, transaction_id, bet_amount, bet_reference_num, game_reference, bet_mode, description, user_id, frontend_type, status, sport_ids, site_id, client_ip, affiliate_user_id, autorecharge, bet_details, currency, potential_win, actual_win, odds, placed_at, settled_at, created_at, updated_at
`

type UpdateSportBetStatusParams struct {
	TransactionID string
	Status        sql.NullString
	ActualWin     decimal.NullDecimal
}

func (q *Queries) UpdateSportBetStatus(ctx context.Context, arg UpdateSportBetStatusParams) (SportBet, error) {
	row := q.db.QueryRow(ctx, updateSportBetStatus, arg.TransactionID, arg.Status, arg.ActualWin)
	var i SportBet
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.BetAmount,
		&i.BetReferenceNum,
		&i.GameReference,
		&i.BetMode,
		&i.Description,
		&i.UserID,
		&i.FrontendType,
		&i.Status,
		&i.SportIds,
		&i.SiteID,
		&i.ClientIp,
		&i.AffiliateUserID,
		&i.Autorecharge,
		&i.BetDetails,
		&i.Currency,
		&i.PotentialWin,
		&i.ActualWin,
		&i.Odds,
		&i.PlacedAt,
		&i.SettledAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

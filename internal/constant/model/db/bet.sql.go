// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bet.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
	"github.com/shopspring/decimal"
)

const cashOut = `-- name: CashOut :one
UPDATE bets SET cash_out_multiplier = $1,payout=$2,timestamp=$3 where id = $4
RETURNING id, user_id, round_id, amount, currency, client_transaction_id, cash_out_multiplier, payout, timestamp, status
`

type CashOutParams struct {
	CashOutMultiplier decimal.NullDecimal
	Payout            decimal.NullDecimal
	Timestamp         sql.NullTime
	ID                uuid.UUID
}

func (q *Queries) CashOut(ctx context.Context, arg CashOutParams) (Bet, error) {
	row := q.db.QueryRow(ctx, cashOut,
		arg.CashOutMultiplier,
		arg.Payout,
		arg.Timestamp,
		arg.ID,
	)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.Amount,
		&i.Currency,
		&i.ClientTransactionID,
		&i.CashOutMultiplier,
		&i.Payout,
		&i.Timestamp,
		&i.Status,
	)
	return i, err
}

const closeRoundByID = `-- name: CloseRoundByID :one
UPDATE rounds SET status = 'closed',closed_at=$1 where id = $2 
RETURNING id, status, crash_point, created_at, closed_at
`

type CloseRoundByIDParams struct {
	ClosedAt sql.NullTime
	ID       uuid.UUID
}

func (q *Queries) CloseRoundByID(ctx context.Context, arg CloseRoundByIDParams) (Round, error) {
	row := q.db.QueryRow(ctx, closeRoundByID, arg.ClosedAt, arg.ID)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CrashPoint,
		&i.CreatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const countPlinkoBetHistoryByUserID = `-- name: CountPlinkoBetHistoryByUserID :one
SELECT count(id) as total from plinko where user_id = $1
`

func (q *Queries) CountPlinkoBetHistoryByUserID(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countPlinkoBetHistoryByUserID, userID)
	var total int64
	err := row.Scan(&total)
	return total, err
}

const getAllFailedRounds = `-- name: GetAllFailedRounds :many
SELECT r.id as round_id,r.crash_point, r.status as round_status,r.created_at as round_created_at,b.id as bet_id,b.amount,b.currency,b.client_transaction_id as bet_transaction_id,b.timestamp as bet_timestamp,fbl.id as failed_bet_id, fbl.manual as is_manual,fbl.status refund_status,fbl.created_at as refund_at,fbl.transaction_id as refund_transaction_id,us.id, us.username, us.phone_number, us.password, us.created_at, us.default_currency, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth, us.source, us.referal_code, us.street_address, us.country, us.state, us.city, us.postal_code, us.kyc_status, us.created_by, us.is_admin, us.status, us.referal_type, us.refered_by_code, us.user_type FROM rounds r join bets b on b.round_id = r.id join failed_bet_logs fbl on fbl.user_id = b.user_id join users us on us.id = b.user_id where r.status='failed' ORDER BY r.created_at limit $1 offset $2
`

type GetAllFailedRoundsParams struct {
	Limit  int32
	Offset int32
}

type GetAllFailedRoundsRow struct {
	RoundID             uuid.UUID
	CrashPoint          decimal.Decimal
	RoundStatus         BetStatus
	RoundCreatedAt      time.Time
	BetID               uuid.UUID
	Amount              decimal.Decimal
	Currency            string
	BetTransactionID    string
	BetTimestamp        sql.NullTime
	FailedBetID         uuid.UUID
	IsManual            bool
	RefundStatus        string
	RefundAt            time.Time
	RefundTransactionID uuid.UUID
	ID                  uuid.UUID
	Username            sql.NullString
	PhoneNumber         sql.NullString
	Password            string
	CreatedAt           time.Time
	DefaultCurrency     sql.NullString
	Profile             sql.NullString
	Email               sql.NullString
	FirstName           sql.NullString
	LastName            sql.NullString
	DateOfBirth         sql.NullString
	Source              sql.NullString
	ReferalCode         sql.NullString
	StreetAddress       string
	Country             string
	State               string
	City                string
	PostalCode          string
	KycStatus           string
	CreatedBy           uuid.NullUUID
	IsAdmin             sql.NullBool
	Status              sql.NullString
	ReferalType         sql.NullString
	ReferedByCode       sql.NullString
	UserType            sql.NullString
}

func (q *Queries) GetAllFailedRounds(ctx context.Context, arg GetAllFailedRoundsParams) ([]GetAllFailedRoundsRow, error) {
	rows, err := q.db.Query(ctx, getAllFailedRounds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllFailedRoundsRow
	for rows.Next() {
		var i GetAllFailedRoundsRow
		if err := rows.Scan(
			&i.RoundID,
			&i.CrashPoint,
			&i.RoundStatus,
			&i.RoundCreatedAt,
			&i.BetID,
			&i.Amount,
			&i.Currency,
			&i.BetTransactionID,
			&i.BetTimestamp,
			&i.FailedBetID,
			&i.IsManual,
			&i.RefundStatus,
			&i.RefundAt,
			&i.RefundTransactionID,
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBetHistory = `-- name: GetBetHistory :many
SELECT 
    rounds.id AS round_id,
    rounds.crash_point, 
    json_agg(
        json_build_object(
            'user_id', bets.user_id,
            'bet_amount', bets.amount,
            'cash_out_multiplier', bets.cash_out_multiplier,
            'payout', bets.payout,
            'currency', bets.currency,
            'timestamp', TO_CHAR(bets.timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.US') || 'Z'
        )
    ) AS bets,COUNT(rounds.id) OVER() AS total
FROM 
    bets 
JOIN 
    rounds 
ON 
    bets.round_id = rounds.id
WHERE 
    rounds.status = 'closed'
GROUP BY 
    rounds.id, rounds.crash_point
OFFSET 
    $1 
LIMIT 
    $2
`

type GetBetHistoryParams struct {
	Offset int32
	Limit  int32
}

type GetBetHistoryRow struct {
	RoundID    uuid.UUID
	CrashPoint decimal.Decimal
	Bets       pgtype.JSON
	Total      int64
}

func (q *Queries) GetBetHistory(ctx context.Context, arg GetBetHistoryParams) ([]GetBetHistoryRow, error) {
	rows, err := q.db.Query(ctx, getBetHistory, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBetHistoryRow
	for rows.Next() {
		var i GetBetHistoryRow
		if err := rows.Scan(
			&i.RoundID,
			&i.CrashPoint,
			&i.Bets,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBetHistoryByUserID = `-- name: GetBetHistoryByUserID :many
SELECT 
    rounds.id AS round_id,
    rounds.crash_point, 
    json_agg(
        json_build_object(
            'user_id', bets.user_id,
            'bet_amount', bets.amount,
            'cash_out_multiplier', bets.cash_out_multiplier,
            'payout', bets.payout,
            'currency', bets.currency,
           'timestamp', TO_CHAR(bets.timestamp, 'YYYY-MM-DD"T"HH24:MI:SS.US') || 'Z'
        )
    ) AS bets,
    COUNT(rounds.id) OVER() AS total
FROM bets
JOIN rounds ON bets.round_id = rounds.id
WHERE bets.user_id = $1 AND rounds.status = 'closed'
GROUP BY rounds.id, rounds.crash_point
ORDER BY rounds.closed_at
OFFSET $2 LIMIT $3
`

type GetBetHistoryByUserIDParams struct {
	UserID uuid.UUID
	Offset int32
	Limit  int32
}

type GetBetHistoryByUserIDRow struct {
	RoundID    uuid.UUID
	CrashPoint decimal.Decimal
	Bets       pgtype.JSON
	Total      int64
}

func (q *Queries) GetBetHistoryByUserID(ctx context.Context, arg GetBetHistoryByUserIDParams) ([]GetBetHistoryByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getBetHistoryByUserID, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBetHistoryByUserIDRow
	for rows.Next() {
		var i GetBetHistoryByUserIDRow
		if err := rows.Scan(
			&i.RoundID,
			&i.CrashPoint,
			&i.Bets,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBetRoundByID = `-- name: GetBetRoundByID :one
SELECT id, status, crash_point, created_at, closed_at FROM rounds where id = $1
`

func (q *Queries) GetBetRoundByID(ctx context.Context, id uuid.UUID) (Round, error) {
	row := q.db.QueryRow(ctx, getBetRoundByID, id)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CrashPoint,
		&i.CreatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const getBetRoundsByStatus = `-- name: GetBetRoundsByStatus :many
SELECT id, status, crash_point, created_at, closed_at FROM rounds where status = $1
`

func (q *Queries) GetBetRoundsByStatus(ctx context.Context, status BetStatus) ([]Round, error) {
	rows, err := q.db.Query(ctx, getBetRoundsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Round
	for rows.Next() {
		var i Round
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CrashPoint,
			&i.CreatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFailedRounds = `-- name: GetFailedRounds :many
SELECT rounds.id, rounds.status, rounds.crash_point, rounds.created_at, rounds.closed_at,b.user_id,b.amount,b.id as bet_id,b.currency FROM rounds join bets b on rounds.id = b.round_id where (rounds.status='open' or rounds.status = 'in_progress') and b.status='ACTIVE' AND rounds.status != 'failed'
`

type GetFailedRoundsRow struct {
	ID         uuid.UUID
	Status     BetStatus
	CrashPoint decimal.Decimal
	CreatedAt  time.Time
	ClosedAt   sql.NullTime
	UserID     uuid.UUID
	Amount     decimal.Decimal
	BetID      uuid.UUID
	Currency   string
}

func (q *Queries) GetFailedRounds(ctx context.Context) ([]GetFailedRoundsRow, error) {
	rows, err := q.db.Query(ctx, getFailedRounds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFailedRoundsRow
	for rows.Next() {
		var i GetFailedRoundsRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CrashPoint,
			&i.CreatedAt,
			&i.ClosedAt,
			&i.UserID,
			&i.Amount,
			&i.BetID,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeaders = `-- name: GetLeaders :many
SELECT 
    users.username,
    profile,
    COALESCE((SUM(bets.payout) - SUM(bets.amount)), 0)::decimal AS total_cash_out,
    COUNT(*) OVER () AS total_players
FROM 
    users
LEFT JOIN 
    bets
ON 
    users.id = bets.user_id
GROUP BY 
    users.id
ORDER BY 
    total_cash_out DESC LIMIT 15
`

type GetLeadersRow struct {
	Username     sql.NullString
	Profile      sql.NullString
	TotalCashOut decimal.Decimal
	TotalPlayers int64
}

func (q *Queries) GetLeaders(ctx context.Context) ([]GetLeadersRow, error) {
	rows, err := q.db.Query(ctx, getLeaders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeadersRow
	for rows.Next() {
		var i GetLeadersRow
		if err := rows.Scan(
			&i.Username,
			&i.Profile,
			&i.TotalCashOut,
			&i.TotalPlayers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlinkoBetHistoryByUserID = `-- name: GetPlinkoBetHistoryByUserID :many
select id, user_id, bet_amount, drop_path, multiplier, win_amount, finalposition, timestamp from plinko where user_id =$1 ORDER BY timestamp DESC LIMIT $2 OFFSET $3
`

type GetPlinkoBetHistoryByUserIDParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetPlinkoBetHistoryByUserID(ctx context.Context, arg GetPlinkoBetHistoryByUserIDParams) ([]Plinko, error) {
	rows, err := q.db.Query(ctx, getPlinkoBetHistoryByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Plinko
	for rows.Next() {
		var i Plinko
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BetAmount,
			&i.DropPath,
			&i.Multiplier,
			&i.WinAmount,
			&i.Finalposition,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnRefundedFaildedRouns = `-- name: GetUnRefundedFaildedRouns :many
SELECT r.id as round_id,r.crash_point, r.status as round_status,r.created_at as round_created_at,b.id as bet_id,b.amount,b.currency,b.client_transaction_id as bet_transaction_id,b.timestamp as bet_timestamp,us.id, us.username, us.phone_number, us.password, us.created_at, us.default_currency, us.profile, us.email, us.first_name, us.last_name, us.date_of_birth, us.source, us.referal_code, us.street_address, us.country, us.state, us.city, us.postal_code, us.kyc_status, us.created_by, us.is_admin, us.status, us.referal_type, us.refered_by_code, us.user_type FROM rounds r join bets b on b.round_id = r.id join users us on us.id = b.user_id where r.status='failed'  and (( select  count(id) from failed_bet_logs fbl where fbl.round_id = b.round_id) = 0) ORDER BY r.created_at limit $1 offset $2
`

type GetUnRefundedFaildedRounsParams struct {
	Limit  int32
	Offset int32
}

type GetUnRefundedFaildedRounsRow struct {
	RoundID          uuid.UUID
	CrashPoint       decimal.Decimal
	RoundStatus      BetStatus
	RoundCreatedAt   time.Time
	BetID            uuid.UUID
	Amount           decimal.Decimal
	Currency         string
	BetTransactionID string
	BetTimestamp     sql.NullTime
	ID               uuid.UUID
	Username         sql.NullString
	PhoneNumber      sql.NullString
	Password         string
	CreatedAt        time.Time
	DefaultCurrency  sql.NullString
	Profile          sql.NullString
	Email            sql.NullString
	FirstName        sql.NullString
	LastName         sql.NullString
	DateOfBirth      sql.NullString
	Source           sql.NullString
	ReferalCode      sql.NullString
	StreetAddress    string
	Country          string
	State            string
	City             string
	PostalCode       string
	KycStatus        string
	CreatedBy        uuid.NullUUID
	IsAdmin          sql.NullBool
	Status           sql.NullString
	ReferalType      sql.NullString
	ReferedByCode    sql.NullString
	UserType         sql.NullString
}

func (q *Queries) GetUnRefundedFaildedRouns(ctx context.Context, arg GetUnRefundedFaildedRounsParams) ([]GetUnRefundedFaildedRounsRow, error) {
	rows, err := q.db.Query(ctx, getUnRefundedFaildedRouns, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnRefundedFaildedRounsRow
	for rows.Next() {
		var i GetUnRefundedFaildedRounsRow
		if err := rows.Scan(
			&i.RoundID,
			&i.CrashPoint,
			&i.RoundStatus,
			&i.RoundCreatedAt,
			&i.BetID,
			&i.Amount,
			&i.Currency,
			&i.BetTransactionID,
			&i.BetTimestamp,
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActiveBetWithRound = `-- name: GetUserActiveBetWithRound :one
SELECT id, user_id, round_id, amount, currency, client_transaction_id, cash_out_multiplier, payout, timestamp, status FROM bets where user_id =  $1 and round_id = $2  and status ='ACTIVE'
`

type GetUserActiveBetWithRoundParams struct {
	UserID  uuid.UUID
	RoundID uuid.UUID
}

func (q *Queries) GetUserActiveBetWithRound(ctx context.Context, arg GetUserActiveBetWithRoundParams) (Bet, error) {
	row := q.db.QueryRow(ctx, getUserActiveBetWithRound, arg.UserID, arg.RoundID)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.Amount,
		&i.Currency,
		&i.ClientTransactionID,
		&i.CashOutMultiplier,
		&i.Payout,
		&i.Timestamp,
		&i.Status,
	)
	return i, err
}

const getUserBetByUserIDAndRoundID = `-- name: GetUserBetByUserIDAndRoundID :many
SELECT id, user_id, round_id, amount, currency, client_transaction_id, cash_out_multiplier, payout, timestamp, status FROM bets where user_id = $1 and round_id = $2 and status = $3
`

type GetUserBetByUserIDAndRoundIDParams struct {
	UserID  uuid.UUID
	RoundID uuid.UUID
	Status  sql.NullString
}

func (q *Queries) GetUserBetByUserIDAndRoundID(ctx context.Context, arg GetUserBetByUserIDAndRoundIDParams) ([]Bet, error) {
	rows, err := q.db.Query(ctx, getUserBetByUserIDAndRoundID, arg.UserID, arg.RoundID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Bet
	for rows.Next() {
		var i Bet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RoundID,
			&i.Amount,
			&i.Currency,
			&i.ClientTransactionID,
			&i.CashOutMultiplier,
			&i.Payout,
			&i.Timestamp,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFundByUserIDAndRoundID = `-- name: GetUserFundByUserIDAndRoundID :one
SELECT id, user_id, round_id, bet_id, manual, admin_id, status, created_at, transaction_id FROM failed_bet_logs where user_id = $1 and round_id =$2 and status ='COMPLTED'
`

type GetUserFundByUserIDAndRoundIDParams struct {
	UserID  uuid.UUID
	RoundID uuid.UUID
}

func (q *Queries) GetUserFundByUserIDAndRoundID(ctx context.Context, arg GetUserFundByUserIDAndRoundIDParams) (FailedBetLog, error) {
	row := q.db.QueryRow(ctx, getUserFundByUserIDAndRoundID, arg.UserID, arg.RoundID)
	var i FailedBetLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.BetID,
		&i.Manual,
		&i.AdminID,
		&i.Status,
		&i.CreatedAt,
		&i.TransactionID,
	)
	return i, err
}

const getUserHighestPlinkoBet = `-- name: GetUserHighestPlinkoBet :one
WITH max_bet AS (
    SELECT MAX(win_amount) AS max_bet
    FROM plinko where user_id = $1
)
SELECT p.id, p.user_id, p.bet_amount, p.drop_path, p.multiplier, p.win_amount, p.finalposition, p.timestamp
FROM plinko p, max_bet m
WHERE p.win_amount = m.max_bet and p.user_id = $1 limit 1
`

func (q *Queries) GetUserHighestPlinkoBet(ctx context.Context, userID uuid.UUID) (Plinko, error) {
	row := q.db.QueryRow(ctx, getUserHighestPlinkoBet, userID)
	var i Plinko
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BetAmount,
		&i.DropPath,
		&i.Multiplier,
		&i.WinAmount,
		&i.Finalposition,
		&i.Timestamp,
	)
	return i, err
}

const placeBet = `-- name: PlaceBet :one
INSERT INTO bets (user_id,round_id,amount,currency,client_transaction_id,timestamp)
VALUES ($1,$2,$3,$4,$5,$6)
RETURNING id, user_id, round_id, amount, currency, client_transaction_id, cash_out_multiplier, payout, timestamp, status
`

type PlaceBetParams struct {
	UserID              uuid.UUID
	RoundID             uuid.UUID
	Amount              decimal.Decimal
	Currency            string
	ClientTransactionID string
	Timestamp           sql.NullTime
}

func (q *Queries) PlaceBet(ctx context.Context, arg PlaceBetParams) (Bet, error) {
	row := q.db.QueryRow(ctx, placeBet,
		arg.UserID,
		arg.RoundID,
		arg.Amount,
		arg.Currency,
		arg.ClientTransactionID,
		arg.Timestamp,
	)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.Amount,
		&i.Currency,
		&i.ClientTransactionID,
		&i.CashOutMultiplier,
		&i.Payout,
		&i.Timestamp,
		&i.Status,
	)
	return i, err
}

const plinkoGameState = `-- name: PlinkoGameState :one
SELECT 
    COUNT(id) AS total_games, 
    SUM(bet_amount)::decimal AS total_wagered, 
    SUM(win_amount)::decimal AS total_win, 
    (SUM(win_amount) - SUM(bet_amount))::decimal AS net_profit, 
    AVG(multiplier)::decimal AS average_multiplier 
FROM plinko 
WHERE user_id = $1
`

type PlinkoGameStateRow struct {
	TotalGames        int64
	TotalWagered      decimal.Decimal
	TotalWin          decimal.Decimal
	NetProfit         decimal.Decimal
	AverageMultiplier decimal.Decimal
}

func (q *Queries) PlinkoGameState(ctx context.Context, userID uuid.UUID) (PlinkoGameStateRow, error) {
	row := q.db.QueryRow(ctx, plinkoGameState, userID)
	var i PlinkoGameStateRow
	err := row.Scan(
		&i.TotalGames,
		&i.TotalWagered,
		&i.TotalWin,
		&i.NetProfit,
		&i.AverageMultiplier,
	)
	return i, err
}

const reverseCashOut = `-- name: ReverseCashOut :one
UPDATE bets SET cash_out_multiplier = NULL,payout=NULL,timestamp=$1 where id = $2
RETURNING id, user_id, round_id, amount, currency, client_transaction_id, cash_out_multiplier, payout, timestamp, status
`

type ReverseCashOutParams struct {
	Timestamp sql.NullTime
	ID        uuid.UUID
}

func (q *Queries) ReverseCashOut(ctx context.Context, arg ReverseCashOutParams) (Bet, error) {
	row := q.db.QueryRow(ctx, reverseCashOut, arg.Timestamp, arg.ID)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.Amount,
		&i.Currency,
		&i.ClientTransactionID,
		&i.CashOutMultiplier,
		&i.Payout,
		&i.Timestamp,
		&i.Status,
	)
	return i, err
}

const saveBetRound = `-- name: SaveBetRound :one
INSERT INTO rounds (status,crash_point,created_at)
VALUES ($1,$2,$3)
RETURNING id, status, crash_point, created_at, closed_at
`

type SaveBetRoundParams struct {
	Status     BetStatus
	CrashPoint decimal.Decimal
	CreatedAt  time.Time
}

func (q *Queries) SaveBetRound(ctx context.Context, arg SaveBetRoundParams) (Round, error) {
	row := q.db.QueryRow(ctx, saveBetRound, arg.Status, arg.CrashPoint, arg.CreatedAt)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CrashPoint,
		&i.CreatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const saveFailedBetsLogAuto = `-- name: SaveFailedBetsLogAuto :one
INSERT INTO failed_bet_logs(user_id,round_id,bet_id,status,manual,created_at,transaction_id,admin_id)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING id, user_id, round_id, bet_id, manual, admin_id, status, created_at, transaction_id
`

type SaveFailedBetsLogAutoParams struct {
	UserID        uuid.UUID
	RoundID       uuid.UUID
	BetID         uuid.UUID
	Status        string
	Manual        bool
	CreatedAt     time.Time
	TransactionID uuid.UUID
	AdminID       uuid.NullUUID
}

func (q *Queries) SaveFailedBetsLogAuto(ctx context.Context, arg SaveFailedBetsLogAutoParams) (FailedBetLog, error) {
	row := q.db.QueryRow(ctx, saveFailedBetsLogAuto,
		arg.UserID,
		arg.RoundID,
		arg.BetID,
		arg.Status,
		arg.Manual,
		arg.CreatedAt,
		arg.TransactionID,
		arg.AdminID,
	)
	var i FailedBetLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.BetID,
		&i.Manual,
		&i.AdminID,
		&i.Status,
		&i.CreatedAt,
		&i.TransactionID,
	)
	return i, err
}

const saveFailedBetsLogManual = `-- name: SaveFailedBetsLogManual :one
INSERT INTO failed_bet_logs(user_id,round_id,bet_id,status,admin_id,manual,created_at,transaction_id)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING id, user_id, round_id, bet_id, manual, admin_id, status, created_at, transaction_id
`

type SaveFailedBetsLogManualParams struct {
	UserID        uuid.UUID
	RoundID       uuid.UUID
	BetID         uuid.UUID
	Status        string
	AdminID       uuid.NullUUID
	Manual        bool
	CreatedAt     time.Time
	TransactionID uuid.UUID
}

func (q *Queries) SaveFailedBetsLogManual(ctx context.Context, arg SaveFailedBetsLogManualParams) (FailedBetLog, error) {
	row := q.db.QueryRow(ctx, saveFailedBetsLogManual,
		arg.UserID,
		arg.RoundID,
		arg.BetID,
		arg.Status,
		arg.AdminID,
		arg.Manual,
		arg.CreatedAt,
		arg.TransactionID,
	)
	var i FailedBetLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.BetID,
		&i.Manual,
		&i.AdminID,
		&i.Status,
		&i.CreatedAt,
		&i.TransactionID,
	)
	return i, err
}

const savePlinkoBet = `-- name: SavePlinkoBet :one
INSERT INTO plinko (user_id,bet_amount,drop_path,multiplier,win_amount,finalPosition,timestamp)
VALUES ($1,$2,$3,$4,$5,$6,$7) RETURNING id, user_id, bet_amount, drop_path, multiplier, win_amount, finalposition, timestamp
`

type SavePlinkoBetParams struct {
	UserID        uuid.UUID
	BetAmount     decimal.Decimal
	DropPath      string
	Multiplier    decimal.NullDecimal
	WinAmount     decimal.NullDecimal
	Finalposition decimal.NullDecimal
	Timestamp     time.Time
}

func (q *Queries) SavePlinkoBet(ctx context.Context, arg SavePlinkoBetParams) (Plinko, error) {
	row := q.db.QueryRow(ctx, savePlinkoBet,
		arg.UserID,
		arg.BetAmount,
		arg.DropPath,
		arg.Multiplier,
		arg.WinAmount,
		arg.Finalposition,
		arg.Timestamp,
	)
	var i Plinko
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BetAmount,
		&i.DropPath,
		&i.Multiplier,
		&i.WinAmount,
		&i.Finalposition,
		&i.Timestamp,
	)
	return i, err
}

const updateBetStatus = `-- name: UpdateBetStatus :one
UPDATE bets set status = $1 where id = $2 RETURNING id, user_id, round_id, amount, currency, client_transaction_id, cash_out_multiplier, payout, timestamp, status
`

type UpdateBetStatusParams struct {
	Status sql.NullString
	ID     uuid.UUID
}

func (q *Queries) UpdateBetStatus(ctx context.Context, arg UpdateBetStatusParams) (Bet, error) {
	row := q.db.QueryRow(ctx, updateBetStatus, arg.Status, arg.ID)
	var i Bet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RoundID,
		&i.Amount,
		&i.Currency,
		&i.ClientTransactionID,
		&i.CashOutMultiplier,
		&i.Payout,
		&i.Timestamp,
		&i.Status,
	)
	return i, err
}

const updateRoundStatusByID = `-- name: UpdateRoundStatusByID :one
UPDATE rounds SET status = $1 where  id = $2
RETURNING id, status, crash_point, created_at, closed_at
`

type UpdateRoundStatusByIDParams struct {
	Status BetStatus
	ID     uuid.UUID
}

func (q *Queries) UpdateRoundStatusByID(ctx context.Context, arg UpdateRoundStatusByIDParams) (Round, error) {
	row := q.db.QueryRow(ctx, updateRoundStatusByID, arg.Status, arg.ID)
	var i Round
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.CrashPoint,
		&i.CreatedAt,
		&i.ClosedAt,
	)
	return i, err
}

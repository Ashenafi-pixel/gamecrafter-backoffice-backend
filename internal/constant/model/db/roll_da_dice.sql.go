// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: roll_da_dice.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createRollDaDice = `-- name: CreateRollDaDice :one
INSERT INTO roll_da_dice(user_id,bet_amount,won_amount,crash_point,user_guessed_start_point,user_guessed_end_point, timestamp,won_status,multiplier,status)
VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING id, user_id, status, bet_amount, won_status, crash_point, timestamp, won_amount, user_guessed_start_point, user_guessed_end_point, multiplier
`

type CreateRollDaDiceParams struct {
	UserID                uuid.UUID
	BetAmount             decimal.Decimal
	WonAmount             decimal.NullDecimal
	CrashPoint            decimal.Decimal
	UserGuessedStartPoint decimal.NullDecimal
	UserGuessedEndPoint   decimal.NullDecimal
	Timestamp             time.Time
	WonStatus             sql.NullString
	Multiplier            decimal.NullDecimal
	Status                string
}

func (q *Queries) CreateRollDaDice(ctx context.Context, arg CreateRollDaDiceParams) (RollDaDice, error) {
	row := q.db.QueryRow(ctx, createRollDaDice,
		arg.UserID,
		arg.BetAmount,
		arg.WonAmount,
		arg.CrashPoint,
		arg.UserGuessedStartPoint,
		arg.UserGuessedEndPoint,
		arg.Timestamp,
		arg.WonStatus,
		arg.Multiplier,
		arg.Status,
	)
	var i RollDaDice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.BetAmount,
		&i.WonStatus,
		&i.CrashPoint,
		&i.Timestamp,
		&i.WonAmount,
		&i.UserGuessedStartPoint,
		&i.UserGuessedEndPoint,
		&i.Multiplier,
	)
	return i, err
}

const getRollDaDiceByID = `-- name: GetRollDaDiceByID :one
SELECT id, user_id, status, bet_amount, won_status, crash_point, timestamp, won_amount, user_guessed_start_point, user_guessed_end_point, multiplier FROM roll_da_dice where id = $1
`

func (q *Queries) GetRollDaDiceByID(ctx context.Context, id uuid.UUID) (RollDaDice, error) {
	row := q.db.QueryRow(ctx, getRollDaDiceByID, id)
	var i RollDaDice
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.BetAmount,
		&i.WonStatus,
		&i.CrashPoint,
		&i.Timestamp,
		&i.WonAmount,
		&i.UserGuessedStartPoint,
		&i.UserGuessedEndPoint,
		&i.Multiplier,
	)
	return i, err
}

const getRollDaDiceHistory = `-- name: GetRollDaDiceHistory :many
WITH roll_da_dice_data AS (
    SELECT id, user_id, status, bet_amount, won_status, crash_point, timestamp, won_amount, user_guessed_start_point, user_guessed_end_point, multiplier
    FROM roll_da_dice
    WHERE user_id = $1 
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM roll_da_dice_data
     WHERE user_id = $1
)
SELECT c.id, c.user_id, c.status, c.bet_amount, c.won_status, c.crash_point, c.timestamp, c.won_amount, c.user_guessed_start_point, c.user_guessed_end_point, c.multiplier, r.total_rows
FROM roll_da_dice_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $2 OFFSET $3
`

type GetRollDaDiceHistoryParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetRollDaDiceHistoryRow struct {
	ID                    uuid.UUID
	UserID                uuid.UUID
	Status                string
	BetAmount             decimal.Decimal
	WonStatus             sql.NullString
	CrashPoint            decimal.Decimal
	Timestamp             time.Time
	WonAmount             decimal.NullDecimal
	UserGuessedStartPoint decimal.NullDecimal
	UserGuessedEndPoint   decimal.NullDecimal
	Multiplier            decimal.NullDecimal
	TotalRows             int64
}

func (q *Queries) GetRollDaDiceHistory(ctx context.Context, arg GetRollDaDiceHistoryParams) ([]GetRollDaDiceHistoryRow, error) {
	rows, err := q.db.Query(ctx, getRollDaDiceHistory, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRollDaDiceHistoryRow
	for rows.Next() {
		var i GetRollDaDiceHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.BetAmount,
			&i.WonStatus,
			&i.CrashPoint,
			&i.Timestamp,
			&i.WonAmount,
			&i.UserGuessedStartPoint,
			&i.UserGuessedEndPoint,
			&i.Multiplier,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

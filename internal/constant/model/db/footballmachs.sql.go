// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: footballmachs.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const addFootballMatchs = `-- name: AddFootballMatchs :one
INSERT INTO football_matchs (round_id,league,date,home_team,away_team,timestamp)
VALUES ($1,$2,$3,$4,$5,$6) RETURNING id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score
`

type AddFootballMatchsParams struct {
	RoundID   uuid.UUID
	League    string
	Date      time.Time
	HomeTeam  string
	AwayTeam  sql.NullString
	Timestamp time.Time
}

func (q *Queries) AddFootballMatchs(ctx context.Context, arg AddFootballMatchsParams) (FootballMatch, error) {
	row := q.db.QueryRow(ctx, addFootballMatchs,
		arg.RoundID,
		arg.League,
		arg.Date,
		arg.HomeTeam,
		arg.AwayTeam,
		arg.Timestamp,
	)
	var i FootballMatch
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.League,
		&i.Date,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Status,
		&i.Won,
		&i.Timestamp,
		&i.HomeScore,
		&i.AwayScore,
	)
	return i, err
}

const closeFootballMatchRound = `-- name: CloseFootballMatchRound :one
UPDATE football_matchs SET status = $1 , home_score = $2, away_score = $3, won = $4 where id = $5 RETURNING id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score
`

type CloseFootballMatchRoundParams struct {
	Status    sql.NullString
	HomeScore sql.NullInt32
	AwayScore sql.NullInt32
	Won       sql.NullString
	ID        uuid.UUID
}

func (q *Queries) CloseFootballMatchRound(ctx context.Context, arg CloseFootballMatchRoundParams) (FootballMatch, error) {
	row := q.db.QueryRow(ctx, closeFootballMatchRound,
		arg.Status,
		arg.HomeScore,
		arg.AwayScore,
		arg.Won,
		arg.ID,
	)
	var i FootballMatch
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.League,
		&i.Date,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Status,
		&i.Won,
		&i.Timestamp,
		&i.HomeScore,
		&i.AwayScore,
	)
	return i, err
}

const createClub = `-- name: CreateClub :one
INSERT INTO clubs (club_name,status,timestamp) VALUES ($1,$2,$3) RETURNING id, club_name, status, timestamp
`

type CreateClubParams struct {
	ClubName  string
	Status    sql.NullString
	Timestamp time.Time
}

func (q *Queries) CreateClub(ctx context.Context, arg CreateClubParams) (Club, error) {
	row := q.db.QueryRow(ctx, createClub, arg.ClubName, arg.Status, arg.Timestamp)
	var i Club
	err := row.Scan(
		&i.ID,
		&i.ClubName,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const createFootballBet = `-- name: CreateFootballBet :one
INSERT INTO users_football_matche_rounds (user_id,football_round_id,bet_amount,won_amount,timestamp) 
VALUES ($1,$2,$3,$4,$5) RETURNING id, status, won_status, user_id, football_round_id, bet_amount, won_amount, timestamp, currency
`

type CreateFootballBetParams struct {
	UserID          uuid.UUID
	FootballRoundID uuid.NullUUID
	BetAmount       decimal.NullDecimal
	WonAmount       decimal.Decimal
	Timestamp       sql.NullTime
}

func (q *Queries) CreateFootballBet(ctx context.Context, arg CreateFootballBetParams) (UsersFootballMatcheRound, error) {
	row := q.db.QueryRow(ctx, createFootballBet,
		arg.UserID,
		arg.FootballRoundID,
		arg.BetAmount,
		arg.WonAmount,
		arg.Timestamp,
	)
	var i UsersFootballMatcheRound
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.WonStatus,
		&i.UserID,
		&i.FootballRoundID,
		&i.BetAmount,
		&i.WonAmount,
		&i.Timestamp,
		&i.Currency,
	)
	return i, err
}

const createFootballBetUserSelection = `-- name: CreateFootballBetUserSelection :one
INSERT INTO users_football_matches (match_id,selection,status,users_football_matche_round_id)
VALUES ($1,$2,$3,$4) RETURNING id, status, match_id, selection, users_football_matche_round_id
`

type CreateFootballBetUserSelectionParams struct {
	MatchID                    uuid.UUID
	Selection                  string
	Status                     string
	UsersFootballMatcheRoundID uuid.NullUUID
}

func (q *Queries) CreateFootballBetUserSelection(ctx context.Context, arg CreateFootballBetUserSelectionParams) (UsersFootballMatch, error) {
	row := q.db.QueryRow(ctx, createFootballBetUserSelection,
		arg.MatchID,
		arg.Selection,
		arg.Status,
		arg.UsersFootballMatcheRoundID,
	)
	var i UsersFootballMatch
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.MatchID,
		&i.Selection,
		&i.UsersFootballMatcheRoundID,
	)
	return i, err
}

const createFootballMatch = `-- name: CreateFootballMatch :one
INSERT INTO football_matchs (round_id,league,date,home_team,away_team,timestamp)
VALUES ($1,$2,$3,$4,$5,$6) RETURNING id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score
`

type CreateFootballMatchParams struct {
	RoundID   uuid.UUID
	League    string
	Date      time.Time
	HomeTeam  string
	AwayTeam  sql.NullString
	Timestamp time.Time
}

func (q *Queries) CreateFootballMatch(ctx context.Context, arg CreateFootballMatchParams) (FootballMatch, error) {
	row := q.db.QueryRow(ctx, createFootballMatch,
		arg.RoundID,
		arg.League,
		arg.Date,
		arg.HomeTeam,
		arg.AwayTeam,
		arg.Timestamp,
	)
	var i FootballMatch
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.League,
		&i.Date,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Status,
		&i.Won,
		&i.Timestamp,
		&i.HomeScore,
		&i.AwayScore,
	)
	return i, err
}

const createFootballMatchRound = `-- name: CreateFootballMatchRound :one
INSERT INTO football_match_rounds (status,timestamp) VALUES ($1,$2) RETURNING id, status, timestamp
`

type CreateFootballMatchRoundParams struct {
	Status    sql.NullString
	Timestamp time.Time
}

func (q *Queries) CreateFootballMatchRound(ctx context.Context, arg CreateFootballMatchRoundParams) (FootballMatchRound, error) {
	row := q.db.QueryRow(ctx, createFootballMatchRound, arg.Status, arg.Timestamp)
	var i FootballMatchRound
	err := row.Scan(&i.ID, &i.Status, &i.Timestamp)
	return i, err
}

const createFootballRound = `-- name: CreateFootballRound :one
INSERT INTO football_match_rounds (status,timestamp) VALUES ($1,$2) RETURNING id, status, timestamp
`

type CreateFootballRoundParams struct {
	Status    sql.NullString
	Timestamp time.Time
}

func (q *Queries) CreateFootballRound(ctx context.Context, arg CreateFootballRoundParams) (FootballMatchRound, error) {
	row := q.db.QueryRow(ctx, createFootballRound, arg.Status, arg.Timestamp)
	var i FootballMatchRound
	err := row.Scan(&i.ID, &i.Status, &i.Timestamp)
	return i, err
}

const createLeague = `-- name: CreateLeague :one
INSERT INTO leagues(league_name,status,timestamp) VALUES ($1,$2,$3) RETURNING id, league_name, status, timestamp
`

type CreateLeagueParams struct {
	LeagueName string
	Status     sql.NullString
	Timestamp  time.Time
}

func (q *Queries) CreateLeague(ctx context.Context, arg CreateLeagueParams) (League, error) {
	row := q.db.QueryRow(ctx, createLeague, arg.LeagueName, arg.Status, arg.Timestamp)
	var i League
	err := row.Scan(
		&i.ID,
		&i.LeagueName,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const getAllFootBallMatchByRoundByRoundID = `-- name: GetAllFootBallMatchByRoundByRoundID :many
SELECT id, status, won_status, user_id, football_round_id, bet_amount, won_amount, timestamp, currency FROM users_football_matche_rounds where football_round_id = $1
`

func (q *Queries) GetAllFootBallMatchByRoundByRoundID(ctx context.Context, footballRoundID uuid.NullUUID) ([]UsersFootballMatcheRound, error) {
	rows, err := q.db.Query(ctx, getAllFootBallMatchByRoundByRoundID, footballRoundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersFootballMatcheRound
	for rows.Next() {
		var i UsersFootballMatcheRound
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.WonStatus,
			&i.UserID,
			&i.FootballRoundID,
			&i.BetAmount,
			&i.WonAmount,
			&i.Timestamp,
			&i.Currency,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserFootballBetByStatusAndRoundID = `-- name: GetAllUserFootballBetByStatusAndRoundID :many
SELECT id, status, match_id, selection, users_football_matche_round_id FROM users_football_matches where status = $1 and users_football_matche_round_id = $2
`

type GetAllUserFootballBetByStatusAndRoundIDParams struct {
	Status                     string
	UsersFootballMatcheRoundID uuid.NullUUID
}

func (q *Queries) GetAllUserFootballBetByStatusAndRoundID(ctx context.Context, arg GetAllUserFootballBetByStatusAndRoundIDParams) ([]UsersFootballMatch, error) {
	rows, err := q.db.Query(ctx, getAllUserFootballBetByStatusAndRoundID, arg.Status, arg.UsersFootballMatcheRoundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersFootballMatch
	for rows.Next() {
		var i UsersFootballMatch
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.MatchID,
			&i.Selection,
			&i.UsersFootballMatcheRoundID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClubByID = `-- name: GetClubByID :one
SELECT id, club_name, status, timestamp FROM clubs where id = $1
`

func (q *Queries) GetClubByID(ctx context.Context, id uuid.UUID) (Club, error) {
	row := q.db.QueryRow(ctx, getClubByID, id)
	var i Club
	err := row.Scan(
		&i.ID,
		&i.ClubName,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const getClubs = `-- name: GetClubs :many
WITH club_data AS (
    SELECT id, club_name, status, timestamp,
           COUNT(*) OVER () as total_rows
    FROM clubs
    WHERE true
)
SELECT id, club_name, status, timestamp, total_rows
FROM club_data
ORDER BY club_name ASC
LIMIT $1 OFFSET $2
`

type GetClubsParams struct {
	Limit  int32
	Offset int32
}

type GetClubsRow struct {
	ID        uuid.UUID
	ClubName  string
	Status    sql.NullString
	Timestamp time.Time
	TotalRows int64
}

func (q *Queries) GetClubs(ctx context.Context, arg GetClubsParams) ([]GetClubsRow, error) {
	rows, err := q.db.Query(ctx, getClubs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClubsRow
	for rows.Next() {
		var i GetClubsRow
		if err := rows.Scan(
			&i.ID,
			&i.ClubName,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchByID = `-- name: GetFootballMatchByID :one
SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score FROM football_matchs where id = $1
`

func (q *Queries) GetFootballMatchByID(ctx context.Context, id uuid.UUID) (FootballMatch, error) {
	row := q.db.QueryRow(ctx, getFootballMatchByID, id)
	var i FootballMatch
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.League,
		&i.Date,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Status,
		&i.Won,
		&i.Timestamp,
		&i.HomeScore,
		&i.AwayScore,
	)
	return i, err
}

const getFootballMatchByRoundID = `-- name: GetFootballMatchByRoundID :many
WITH match_data AS (
    SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score,
           COUNT(*) OVER () as total_rows
    FROM football_matchs
    WHERE round_id = $1
)
SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score, total_rows FROM match_data ORDER BY timestamp DESC LIMIT $2 OFFSET $3
`

type GetFootballMatchByRoundIDParams struct {
	RoundID uuid.UUID
	Limit   int32
	Offset  int32
}

type GetFootballMatchByRoundIDRow struct {
	ID        uuid.UUID
	RoundID   uuid.UUID
	League    string
	Date      time.Time
	HomeTeam  string
	AwayTeam  sql.NullString
	Status    sql.NullString
	Won       sql.NullString
	Timestamp time.Time
	HomeScore sql.NullInt32
	AwayScore sql.NullInt32
	TotalRows int64
}

func (q *Queries) GetFootballMatchByRoundID(ctx context.Context, arg GetFootballMatchByRoundIDParams) ([]GetFootballMatchByRoundIDRow, error) {
	rows, err := q.db.Query(ctx, getFootballMatchByRoundID, arg.RoundID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFootballMatchByRoundIDRow
	for rows.Next() {
		var i GetFootballMatchByRoundIDRow
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.League,
			&i.Date,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Status,
			&i.Won,
			&i.Timestamp,
			&i.HomeScore,
			&i.AwayScore,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchByRoundStatus = `-- name: GetFootballMatchByRoundStatus :many
select m.id, m.round_id, m.league, m.date, m.home_team, m.away_team, m.status, m.won, m.timestamp, m.home_score, m.away_score,r.status from football_matchs m join football_match_rounds r on r.id = m.round_id where r.status=$1
`

type GetFootballMatchByRoundStatusRow struct {
	ID        uuid.UUID
	RoundID   uuid.UUID
	League    string
	Date      time.Time
	HomeTeam  string
	AwayTeam  sql.NullString
	Status    sql.NullString
	Won       sql.NullString
	Timestamp time.Time
	HomeScore sql.NullInt32
	AwayScore sql.NullInt32
	Status_2  sql.NullString
}

func (q *Queries) GetFootballMatchByRoundStatus(ctx context.Context, status sql.NullString) ([]GetFootballMatchByRoundStatusRow, error) {
	rows, err := q.db.Query(ctx, getFootballMatchByRoundStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFootballMatchByRoundStatusRow
	for rows.Next() {
		var i GetFootballMatchByRoundStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.League,
			&i.Date,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Status,
			&i.Won,
			&i.Timestamp,
			&i.HomeScore,
			&i.AwayScore,
			&i.Status_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchByStatus = `-- name: GetFootballMatchByStatus :many
WITH match_data AS (
    SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score,
           COUNT(*) OVER () as total_rows
    FROM football_matchs
    WHERE status = $1
)
SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score, total_rows FROM match_data ORDER BY timestamp DESC LIMIT $2 OFFSET $3
`

type GetFootballMatchByStatusParams struct {
	Status sql.NullString
	Limit  int32
	Offset int32
}

type GetFootballMatchByStatusRow struct {
	ID        uuid.UUID
	RoundID   uuid.UUID
	League    string
	Date      time.Time
	HomeTeam  string
	AwayTeam  sql.NullString
	Status    sql.NullString
	Won       sql.NullString
	Timestamp time.Time
	HomeScore sql.NullInt32
	AwayScore sql.NullInt32
	TotalRows int64
}

func (q *Queries) GetFootballMatchByStatus(ctx context.Context, arg GetFootballMatchByStatusParams) ([]GetFootballMatchByStatusRow, error) {
	rows, err := q.db.Query(ctx, getFootballMatchByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFootballMatchByStatusRow
	for rows.Next() {
		var i GetFootballMatchByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.League,
			&i.Date,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Status,
			&i.Won,
			&i.Timestamp,
			&i.HomeScore,
			&i.AwayScore,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchRound = `-- name: GetFootballMatchRound :many
WITH match_data AS (
    SELECT id, status, timestamp,
           COUNT(*) OVER () as total_rows
    FROM football_match_rounds
    WHERE true
)
SELECT id, status, timestamp, total_rows
FROM match_data
ORDER BY timestamp DESC
LIMIT $1 OFFSET $2
`

type GetFootballMatchRoundParams struct {
	Limit  int32
	Offset int32
}

type GetFootballMatchRoundRow struct {
	ID        uuid.UUID
	Status    sql.NullString
	Timestamp time.Time
	TotalRows int64
}

func (q *Queries) GetFootballMatchRound(ctx context.Context, arg GetFootballMatchRoundParams) ([]GetFootballMatchRoundRow, error) {
	rows, err := q.db.Query(ctx, getFootballMatchRound, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFootballMatchRoundRow
	for rows.Next() {
		var i GetFootballMatchRoundRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchRoundByID = `-- name: GetFootballMatchRoundByID :one
SELECT id, status, timestamp FROM football_match_rounds where id = $1
`

func (q *Queries) GetFootballMatchRoundByID(ctx context.Context, id uuid.UUID) (FootballMatchRound, error) {
	row := q.db.QueryRow(ctx, getFootballMatchRoundByID, id)
	var i FootballMatchRound
	err := row.Scan(&i.ID, &i.Status, &i.Timestamp)
	return i, err
}

const getFootballMatchRoundByStatus = `-- name: GetFootballMatchRoundByStatus :many
WITH match_data AS (
    SELECT id, status, timestamp,
           COUNT(*) OVER () as total_rows
    FROM football_match_rounds
    WHERE  status = $1
)
SELECT id, status, timestamp, total_rows
FROM match_data 
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type GetFootballMatchRoundByStatusParams struct {
	Status sql.NullString
	Limit  int32
	Offset int32
}

type GetFootballMatchRoundByStatusRow struct {
	ID        uuid.UUID
	Status    sql.NullString
	Timestamp time.Time
	TotalRows int64
}

func (q *Queries) GetFootballMatchRoundByStatus(ctx context.Context, arg GetFootballMatchRoundByStatusParams) ([]GetFootballMatchRoundByStatusRow, error) {
	rows, err := q.db.Query(ctx, getFootballMatchRoundByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFootballMatchRoundByStatusRow
	for rows.Next() {
		var i GetFootballMatchRoundByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchesByRoundID = `-- name: GetFootballMatchesByRoundID :many
SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score FROM football_matchs where round_id = $1
`

func (q *Queries) GetFootballMatchesByRoundID(ctx context.Context, roundID uuid.UUID) ([]FootballMatch, error) {
	rows, err := q.db.Query(ctx, getFootballMatchesByRoundID, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FootballMatch
	for rows.Next() {
		var i FootballMatch
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.League,
			&i.Date,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Status,
			&i.Won,
			&i.Timestamp,
			&i.HomeScore,
			&i.AwayScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchesByStatus = `-- name: GetFootballMatchesByStatus :many
SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score FROM football_matchs where status = $1 and round_id = $2
`

type GetFootballMatchesByStatusParams struct {
	Status  sql.NullString
	RoundID uuid.UUID
}

func (q *Queries) GetFootballMatchesByStatus(ctx context.Context, arg GetFootballMatchesByStatusParams) ([]FootballMatch, error) {
	rows, err := q.db.Query(ctx, getFootballMatchesByStatus, arg.Status, arg.RoundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FootballMatch
	for rows.Next() {
		var i FootballMatch
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.League,
			&i.Date,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Status,
			&i.Won,
			&i.Timestamp,
			&i.HomeScore,
			&i.AwayScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballMatchs = `-- name: GetFootballMatchs :many
WITH match_data AS (
    SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score,
           COUNT(*) OVER () as total_rows
    FROM football_matchs
    WHERE true
)
SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score, total_rows FROM match_data ORDER BY timestamp DESC LIMIT $1 OFFSET $2
`

type GetFootballMatchsParams struct {
	Limit  int32
	Offset int32
}

type GetFootballMatchsRow struct {
	ID        uuid.UUID
	RoundID   uuid.UUID
	League    string
	Date      time.Time
	HomeTeam  string
	AwayTeam  sql.NullString
	Status    sql.NullString
	Won       sql.NullString
	Timestamp time.Time
	HomeScore sql.NullInt32
	AwayScore sql.NullInt32
	TotalRows int64
}

func (q *Queries) GetFootballMatchs(ctx context.Context, arg GetFootballMatchsParams) ([]GetFootballMatchsRow, error) {
	rows, err := q.db.Query(ctx, getFootballMatchs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFootballMatchsRow
	for rows.Next() {
		var i GetFootballMatchsRow
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.League,
			&i.Date,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Status,
			&i.Won,
			&i.Timestamp,
			&i.HomeScore,
			&i.AwayScore,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootballRoundMatchs = `-- name: GetFootballRoundMatchs :many
WITH match_data AS (
    SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score,
           COUNT(*) OVER () as total_rows
    FROM football_matchs
    WHERE round_id = $1
)
SELECT id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score, total_rows FROM match_data ORDER BY timestamp DESC LIMIT $2 OFFSET $3
`

type GetFootballRoundMatchsParams struct {
	RoundID uuid.UUID
	Limit   int32
	Offset  int32
}

type GetFootballRoundMatchsRow struct {
	ID        uuid.UUID
	RoundID   uuid.UUID
	League    string
	Date      time.Time
	HomeTeam  string
	AwayTeam  sql.NullString
	Status    sql.NullString
	Won       sql.NullString
	Timestamp time.Time
	HomeScore sql.NullInt32
	AwayScore sql.NullInt32
	TotalRows int64
}

func (q *Queries) GetFootballRoundMatchs(ctx context.Context, arg GetFootballRoundMatchsParams) ([]GetFootballRoundMatchsRow, error) {
	rows, err := q.db.Query(ctx, getFootballRoundMatchs, arg.RoundID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFootballRoundMatchsRow
	for rows.Next() {
		var i GetFootballRoundMatchsRow
		if err := rows.Scan(
			&i.ID,
			&i.RoundID,
			&i.League,
			&i.Date,
			&i.HomeTeam,
			&i.AwayTeam,
			&i.Status,
			&i.Won,
			&i.Timestamp,
			&i.HomeScore,
			&i.AwayScore,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLeagueByID = `-- name: GetLeagueByID :one
SELECT id, league_name, status, timestamp FROM leagues where id = $1
`

func (q *Queries) GetLeagueByID(ctx context.Context, id uuid.UUID) (League, error) {
	row := q.db.QueryRow(ctx, getLeagueByID, id)
	var i League
	err := row.Scan(
		&i.ID,
		&i.LeagueName,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const getLeagues = `-- name: GetLeagues :many
WITH league_data AS (
    SELECT id, league_name, status, timestamp,
           COUNT(*) OVER () as total_rows
    FROM leagues
    WHERE true
)
SELECT id, league_name, status, timestamp, total_rows
FROM league_data
ORDER BY league_name ASC
LIMIT $1 OFFSET $2
`

type GetLeaguesParams struct {
	Limit  int32
	Offset int32
}

type GetLeaguesRow struct {
	ID         uuid.UUID
	LeagueName string
	Status     sql.NullString
	Timestamp  time.Time
	TotalRows  int64
}

func (q *Queries) GetLeagues(ctx context.Context, arg GetLeaguesParams) ([]GetLeaguesRow, error) {
	rows, err := q.db.Query(ctx, getLeagues, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLeaguesRow
	for rows.Next() {
		var i GetLeaguesRow
		if err := rows.Scan(
			&i.ID,
			&i.LeagueName,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFootballBetMatchesForUserBet = `-- name: GetUserFootballBetMatchesForUserBet :many
SELECT  id, status, match_id, selection, users_football_matche_round_id FROM users_football_matches where users_football_matche_round_id = $1
`

func (q *Queries) GetUserFootballBetMatchesForUserBet(ctx context.Context, usersFootballMatcheRoundID uuid.NullUUID) ([]UsersFootballMatch, error) {
	rows, err := q.db.Query(ctx, getUserFootballBetMatchesForUserBet, usersFootballMatcheRoundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersFootballMatch
	for rows.Next() {
		var i UsersFootballMatch
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.MatchID,
			&i.Selection,
			&i.UsersFootballMatcheRoundID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFootballBets = `-- name: GetUserFootballBets :many
WITH match_rounds AS (
    SELECT id, status, won_status, user_id, football_round_id, bet_amount, won_amount, timestamp, currency,
           COUNT(*) OVER () as total_rows
    FROM users_football_matche_rounds ufmr where user_id = $1
)
SELECT 
    status AS round_status,
    id,
    bet_amount,
    won_amount AS winning_amount,
    currency,
    total_rows
FROM 
    match_rounds 
ORDER BY 
    timestamp DESC 
LIMIT $2 
OFFSET $3
`

type GetUserFootballBetsParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserFootballBetsRow struct {
	RoundStatus   string
	ID            uuid.UUID
	BetAmount     decimal.NullDecimal
	WinningAmount decimal.Decimal
	Currency      string
	TotalRows     int64
}

func (q *Queries) GetUserFootballBets(ctx context.Context, arg GetUserFootballBetsParams) ([]GetUserFootballBetsRow, error) {
	rows, err := q.db.Query(ctx, getUserFootballBets, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserFootballBetsRow
	for rows.Next() {
		var i GetUserFootballBetsRow
		if err := rows.Scan(
			&i.RoundStatus,
			&i.ID,
			&i.BetAmount,
			&i.WinningAmount,
			&i.Currency,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserFootballMatchSelectionsByMatchID = `-- name: GetUserFootballMatchSelectionsByMatchID :many
SELECT id, status, match_id, selection, users_football_matche_round_id FROM users_football_matches where match_id = $1
`

func (q *Queries) GetUserFootballMatchSelectionsByMatchID(ctx context.Context, matchID uuid.UUID) ([]UsersFootballMatch, error) {
	rows, err := q.db.Query(ctx, getUserFootballMatchSelectionsByMatchID, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UsersFootballMatch
	for rows.Next() {
		var i UsersFootballMatch
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.MatchID,
			&i.Selection,
			&i.UsersFootballMatcheRoundID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClubNameByID = `-- name: UpdateClubNameByID :one
UPDATE clubs SET club_name = $1 where id = $2 RETURNING id, club_name, status, timestamp
`

type UpdateClubNameByIDParams struct {
	ClubName string
	ID       uuid.UUID
}

func (q *Queries) UpdateClubNameByID(ctx context.Context, arg UpdateClubNameByIDParams) (Club, error) {
	row := q.db.QueryRow(ctx, updateClubNameByID, arg.ClubName, arg.ID)
	var i Club
	err := row.Scan(
		&i.ID,
		&i.ClubName,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const updateFootballMatchsByID = `-- name: UpdateFootballMatchsByID :one
UPDATE football_matchs set status = $1 where id = $2 RETURNING id, round_id, league, date, home_team, away_team, status, won, timestamp, home_score, away_score
`

type UpdateFootballMatchsByIDParams struct {
	Status sql.NullString
	ID     uuid.UUID
}

func (q *Queries) UpdateFootballMatchsByID(ctx context.Context, arg UpdateFootballMatchsByIDParams) (FootballMatch, error) {
	row := q.db.QueryRow(ctx, updateFootballMatchsByID, arg.Status, arg.ID)
	var i FootballMatch
	err := row.Scan(
		&i.ID,
		&i.RoundID,
		&i.League,
		&i.Date,
		&i.HomeTeam,
		&i.AwayTeam,
		&i.Status,
		&i.Won,
		&i.Timestamp,
		&i.HomeScore,
		&i.AwayScore,
	)
	return i, err
}

const updateFootballmatchByRoundID = `-- name: UpdateFootballmatchByRoundID :one
UPDATE football_match_rounds set status = $1 where id = $2 RETURNING id, status, timestamp
`

type UpdateFootballmatchByRoundIDParams struct {
	Status sql.NullString
	ID     uuid.UUID
}

func (q *Queries) UpdateFootballmatchByRoundID(ctx context.Context, arg UpdateFootballmatchByRoundIDParams) (FootballMatchRound, error) {
	row := q.db.QueryRow(ctx, updateFootballmatchByRoundID, arg.Status, arg.ID)
	var i FootballMatchRound
	err := row.Scan(&i.ID, &i.Status, &i.Timestamp)
	return i, err
}

const updateLeagueNameByID = `-- name: UpdateLeagueNameByID :one
UPDATE leagues SET league_name = $1 where id = $2 RETURNING id, league_name, status, timestamp
`

type UpdateLeagueNameByIDParams struct {
	LeagueName string
	ID         uuid.UUID
}

func (q *Queries) UpdateLeagueNameByID(ctx context.Context, arg UpdateLeagueNameByIDParams) (League, error) {
	row := q.db.QueryRow(ctx, updateLeagueNameByID, arg.LeagueName, arg.ID)
	var i League
	err := row.Scan(
		&i.ID,
		&i.LeagueName,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const updateUserFootballMatchStatusByMatchID = `-- name: UpdateUserFootballMatchStatusByMatchID :one
UPDATE users_football_matches SET status = $1 where id = $2 RETURNING id, status, match_id, selection, users_football_matche_round_id
`

type UpdateUserFootballMatchStatusByMatchIDParams struct {
	Status string
	ID     uuid.UUID
}

func (q *Queries) UpdateUserFootballMatchStatusByMatchID(ctx context.Context, arg UpdateUserFootballMatchStatusByMatchIDParams) (UsersFootballMatch, error) {
	row := q.db.QueryRow(ctx, updateUserFootballMatchStatusByMatchID, arg.Status, arg.ID)
	var i UsersFootballMatch
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.MatchID,
		&i.Selection,
		&i.UsersFootballMatcheRoundID,
	)
	return i, err
}

const updateUserFootballMatcheRoundsByID = `-- name: UpdateUserFootballMatcheRoundsByID :exec
UPDATE users_football_matche_rounds SET status = $1, won_status = $2 WHERE id = $3
`

type UpdateUserFootballMatcheRoundsByIDParams struct {
	Status    string
	WonStatus sql.NullString
	ID        uuid.UUID
}

func (q *Queries) UpdateUserFootballMatcheRoundsByID(ctx context.Context, arg UpdateUserFootballMatcheRoundsByIDParams) error {
	_, err := q.db.Exec(ctx, updateUserFootballMatcheRoundsByID, arg.Status, arg.WonStatus, arg.ID)
	return err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: quick_hustles.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const closeQuickHustleGame = `-- name: CloseQuickHustleGame :one
UPDATE  quick_hustles set user_guessed = $1,won_status = $2 , second_card = $3,won_amount = $4,status = $5 where id = $6
RETURNING id, user_id, status, bet_amount, won_status, user_guessed, first_card, second_card, timestamp, won_amount
`

type CloseQuickHustleGameParams struct {
	UserGuessed sql.NullString
	WonStatus   sql.NullString
	SecondCard  sql.NullString
	WonAmount   decimal.NullDecimal
	Status      string
	ID          uuid.UUID
}

func (q *Queries) CloseQuickHustleGame(ctx context.Context, arg CloseQuickHustleGameParams) (QuickHustle, error) {
	row := q.db.QueryRow(ctx, closeQuickHustleGame,
		arg.UserGuessed,
		arg.WonStatus,
		arg.SecondCard,
		arg.WonAmount,
		arg.Status,
		arg.ID,
	)
	var i QuickHustle
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.BetAmount,
		&i.WonStatus,
		&i.UserGuessed,
		&i.FirstCard,
		&i.SecondCard,
		&i.Timestamp,
		&i.WonAmount,
	)
	return i, err
}

const createQuickHustle = `-- name: CreateQuickHustle :one
INSERT INTO quick_hustles (user_id,bet_amount,first_card,timestamp)
VALUES ($1,$2,$3,$4) RETURNING id, user_id, status, bet_amount, won_status, user_guessed, first_card, second_card, timestamp, won_amount
`

type CreateQuickHustleParams struct {
	UserID    uuid.UUID
	BetAmount decimal.Decimal
	FirstCard string
	Timestamp time.Time
}

func (q *Queries) CreateQuickHustle(ctx context.Context, arg CreateQuickHustleParams) (QuickHustle, error) {
	row := q.db.QueryRow(ctx, createQuickHustle,
		arg.UserID,
		arg.BetAmount,
		arg.FirstCard,
		arg.Timestamp,
	)
	var i QuickHustle
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.BetAmount,
		&i.WonStatus,
		&i.UserGuessed,
		&i.FirstCard,
		&i.SecondCard,
		&i.Timestamp,
		&i.WonAmount,
	)
	return i, err
}

const getQuickHustelByID = `-- name: GetQuickHustelByID :one
SELECT id, user_id, status, bet_amount, won_status, user_guessed, first_card, second_card, timestamp, won_amount FROM quick_hustles where id = $1
`

func (q *Queries) GetQuickHustelByID(ctx context.Context, id uuid.UUID) (QuickHustle, error) {
	row := q.db.QueryRow(ctx, getQuickHustelByID, id)
	var i QuickHustle
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.BetAmount,
		&i.WonStatus,
		&i.UserGuessed,
		&i.FirstCard,
		&i.SecondCard,
		&i.Timestamp,
		&i.WonAmount,
	)
	return i, err
}

const getQuickHustleBetHistoy = `-- name: GetQuickHustleBetHistoy :many
 WITH crash_king_data AS (
    SELECT id, user_id, status, bet_amount, won_status, user_guessed, first_card, second_card, timestamp, won_amount
    FROM quick_hustles
    WHERE user_id = $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM crash_king_data  WHERE user_id = $1
)
SELECT c.id, c.user_id, c.status, c.bet_amount, c.won_status, c.user_guessed, c.first_card, c.second_card, c.timestamp, c.won_amount, r.total_rows
FROM crash_king_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $2 OFFSET $3
`

type GetQuickHustleBetHistoyParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetQuickHustleBetHistoyRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	Status      string
	BetAmount   decimal.Decimal
	WonStatus   sql.NullString
	UserGuessed sql.NullString
	FirstCard   string
	SecondCard  sql.NullString
	Timestamp   time.Time
	WonAmount   decimal.NullDecimal
	TotalRows   int64
}

func (q *Queries) GetQuickHustleBetHistoy(ctx context.Context, arg GetQuickHustleBetHistoyParams) ([]GetQuickHustleBetHistoyRow, error) {
	rows, err := q.db.Query(ctx, getQuickHustleBetHistoy, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuickHustleBetHistoyRow
	for rows.Next() {
		var i GetQuickHustleBetHistoyRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.BetAmount,
			&i.WonStatus,
			&i.UserGuessed,
			&i.FirstCard,
			&i.SecondCard,
			&i.Timestamp,
			&i.WonAmount,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

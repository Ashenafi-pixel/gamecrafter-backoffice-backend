// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: authz.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const addRoleToUser = `-- name: AddRoleToUser :one
INSERT INTO user_roles (user_id,role_id) VALUES ( $1,$2) RETURNING id, user_id, role_id
`

type AddRoleToUserParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) AddRoleToUser(ctx context.Context, arg AddRoleToUserParams) (UserRole, error) {
	row := q.db.QueryRow(ctx, addRoleToUser, arg.UserID, arg.RoleID)
	var i UserRole
	err := row.Scan(&i.ID, &i.UserID, &i.RoleID)
	return i, err
}

const addSupperAdminCasbinRule = `-- name: AddSupperAdminCasbinRule :one
insert into casbin_rule (ptype,v0,v1,v2) values ('p',$1,'*','*') RETURNING id, ptype, v0, v1, v2, v3, v4, v5
`

func (q *Queries) AddSupperAdminCasbinRule(ctx context.Context, v0 sql.NullString) (CasbinRule, error) {
	row := q.db.QueryRow(ctx, addSupperAdminCasbinRule, v0)
	var i CasbinRule
	err := row.Scan(
		&i.ID,
		&i.Ptype,
		&i.V0,
		&i.V1,
		&i.V2,
		&i.V3,
		&i.V4,
		&i.V5,
	)
	return i, err
}

const assignPermissionToRole = `-- name: AssignPermissionToRole :one
INSERT INTO role_permissions (role_id,permission_id,value) values ($1,$2,$3) RETURNING id, role_id, permission_id, value
`

type AssignPermissionToRoleParams struct {
	RoleID       uuid.UUID
	PermissionID uuid.UUID
	Value        *decimal.Decimal
}

func (q *Queries) AssignPermissionToRole(ctx context.Context, arg AssignPermissionToRoleParams) (RolePermission, error) {
	// Convert *decimal.Decimal to sql.NullString for scanning
	var valueParam interface{}
	if arg.Value != nil {
		valueParam = *arg.Value
	} else {
		valueParam = nil
	}
	
	row := q.db.QueryRow(ctx, assignPermissionToRole, arg.RoleID, arg.PermissionID, valueParam)
	var i RolePermission
	err := row.Scan(&i.ID, &i.RoleID, &i.PermissionID, &i.Value)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (name) values ($1) RETURNING id, name, description
`

func (q *Queries) CreateRole(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRow(ctx, createRole, name)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getPermissionByID = `-- name: GetPermissionByID :one
SELECT id, name, description from permissions where id = $1
`

func (q *Queries) GetPermissionByID(ctx context.Context, id uuid.UUID) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionByID, id)
	var i Permission
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getPermissions = `-- name: GetPermissions :many
SELECT id, name, description FROM permissions where true limit $1 offset $2
`

type GetPermissionsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetPermissions(ctx context.Context, arg GetPermissionsParams) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getPermissions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPermissonByName = `-- name: GetPermissonByName :one
SELECT id, name, description FROM permissions where name = $1
`

func (q *Queries) GetPermissonByName(ctx context.Context, name string) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissonByName, name)
	var i Permission
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, name, description FROM roles where id = $1
`

func (q *Queries) GetRoleByID(ctx context.Context, id uuid.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByID, id)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, description FROM roles where name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT id, name, description FROM permissions where id in (select permission_id from role_permissions where role_id = $1)
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID uuid.UUID) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRolePermissionsForRole = `-- name: GetRolePermissionsForRole :many
SELECT id, role_id, permission_id FROM role_permissions where role_id = $1
`

func (q *Queries) GetRolePermissionsForRole(ctx context.Context, roleID uuid.UUID) ([]RolePermission, error) {
	rows, err := q.db.Query(ctx, getRolePermissionsForRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RolePermission
	for rows.Next() {
		var i RolePermission
		if err := rows.Scan(&i.ID, &i.RoleID, &i.PermissionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoleUsers = `-- name: GetRoleUsers :many
SELECT u.id, u.username, u.phone_number, u.password, u.created_at, u.default_currency, u.profile, u.email, u.first_name, u.last_name, u.date_of_birth, u.source, u.referal_code, u.street_address, u.country, u.state, u.city, u.postal_code, u.kyc_status, u.created_by, u.is_admin, u.status, u.referal_type, u.refered_by_code, u.user_type from user_roles ur join users u on ur.user_id = u.id where role_id = $1
`

func (q *Queries) GetRoleUsers(ctx context.Context, roleID uuid.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, getRoleUsers, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoles = `-- name: GetRoles :many
SELECT id, name, description FROM roles where true limit $1 offset $2
`

type GetRolesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetRoles(ctx context.Context, arg GetRolesParams) ([]Role, error) {
	rows, err := q.db.Query(ctx, getRoles, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupperAdmin = `-- name: GetSupperAdmin :one
SELECT id, name, description FROM roles where name = 'super'
`

func (q *Queries) GetSupperAdmin(ctx context.Context) (Role, error) {
	row := q.db.QueryRow(ctx, getSupperAdmin)
	var i Role
	err := row.Scan(&i.ID, &i.Name, &i.Description)
	return i, err
}

const getUserRoleByUserIDandRoleID = `-- name: GetUserRoleByUserIDandRoleID :one
SELECT id, user_id, role_id FROM user_roles where role_id = $1 and user_id = $2
`

type GetUserRoleByUserIDandRoleIDParams struct {
	RoleID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) GetUserRoleByUserIDandRoleID(ctx context.Context, arg GetUserRoleByUserIDandRoleIDParams) (UserRole, error) {
	row := q.db.QueryRow(ctx, getUserRoleByUserIDandRoleID, arg.RoleID, arg.UserID)
	var i UserRole
	err := row.Scan(&i.ID, &i.UserID, &i.RoleID)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT id, user_id, role_id FROM user_roles where user_id = $1
`

func (q *Queries) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]UserRole, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRole
	for rows.Next() {
		var i UserRole
		if err := rows.Scan(&i.ID, &i.UserID, &i.RoleID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeRole = `-- name: RemoveRole :exec
DELETE FROM roles where id = $1
`

func (q *Queries) RemoveRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeRole, id)
	return err
}

const removeRoleFromUserRoles = `-- name: RemoveRoleFromUserRoles :exec
DELETE FROM user_roles where role_id = $1
`

func (q *Queries) RemoveRoleFromUserRoles(ctx context.Context, roleID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeRoleFromUserRoles, roleID)
	return err
}

const removeRolesPermissionByRoleID = `-- name: RemoveRolesPermissionByRoleID :exec
DELETE FROM role_permissions where role_id = $1
`

func (q *Queries) RemoveRolesPermissionByRoleID(ctx context.Context, roleID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeRolesPermissionByRoleID, roleID)
	return err
}

const removeRolesPermissions = `-- name: RemoveRolesPermissions :exec
DELETE FROM role_permissions where id = $1
`

func (q *Queries) RemoveRolesPermissions(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeRolesPermissions, id)
	return err
}

const revokeUserRole = `-- name: RevokeUserRole :exec
DELETE FROM  user_roles where user_id = $1 and role_id = $2
`

type RevokeUserRoleParams struct {
	UserID uuid.UUID
	RoleID uuid.UUID
}

func (q *Queries) RevokeUserRole(ctx context.Context, arg RevokeUserRoleParams) error {
	_, err := q.db.Exec(ctx, revokeUserRole, arg.UserID, arg.RoleID)
	return err
}

const removeAllUserRolesExceptSuper = `-- name: RemoveAllUserRolesExceptSuper :exec
DELETE FROM user_roles 
WHERE user_id = $1 
AND role_id NOT IN (SELECT id FROM roles WHERE name = 'super')
`

func (q *Queries) RemoveAllUserRolesExceptSuper(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAllUserRolesExceptSuper, userID)
	return err
}

const getAdminFundingLimit = `-- name: GetAdminFundingLimit :one
SELECT COALESCE(MAX(rp.value), NULL) as max_funding_limit
FROM user_roles ur
JOIN role_permissions rp ON ur.role_id = rp.role_id
JOIN permissions p ON rp.permission_id = p.id
WHERE ur.user_id = $1 AND p.name = 'manual funding'
`

type GetAdminFundingLimitRow struct {
	MaxFundingLimit decimal.NullDecimal
}

func (q *Queries) GetAdminFundingLimit(ctx context.Context, userID uuid.UUID) (GetAdminFundingLimitRow, error) {
	row := q.db.QueryRow(ctx, getAdminFundingLimit, userID)
	var i GetAdminFundingLimitRow
	err := row.Scan(&i.MaxFundingLimit)
	return i, err
}

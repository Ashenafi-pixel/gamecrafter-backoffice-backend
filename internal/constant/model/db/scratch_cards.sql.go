// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scratch_cards.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createScratchCardsBet = `-- name: CreateScratchCardsBet :one
INSERT INTO scratch_cards(user_id,status,bet_amount,won_amount,won_status,timestamp)
VALUES ($1,$2,$3,$4,$5,$6) RETURNING id, user_id, status, bet_amount, won_status, timestamp, won_amount
`

type CreateScratchCardsBetParams struct {
	UserID    uuid.UUID
	Status    string
	BetAmount decimal.Decimal
	WonAmount decimal.NullDecimal
	WonStatus sql.NullString
	Timestamp time.Time
}

func (q *Queries) CreateScratchCardsBet(ctx context.Context, arg CreateScratchCardsBetParams) (ScratchCard, error) {
	row := q.db.QueryRow(ctx, createScratchCardsBet,
		arg.UserID,
		arg.Status,
		arg.BetAmount,
		arg.WonAmount,
		arg.WonStatus,
		arg.Timestamp,
	)
	var i ScratchCard
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.BetAmount,
		&i.WonStatus,
		&i.Timestamp,
		&i.WonAmount,
	)
	return i, err
}

const getUserScratchCardBetHistories = `-- name: GetUserScratchCardBetHistories :many
WITH scratch_cards_data AS (
    SELECT id, user_id, status, bet_amount, won_status, timestamp, won_amount
    FROM scratch_cards
    WHERE user_id = $1 and status = 'CLOSED' 
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM scratch_cards_data
     WHERE user_id = $1 AND status = 'CLOSED'
)
SELECT c.id, c.user_id, c.status, c.bet_amount, c.won_status, c.timestamp, c.won_amount, r.total_rows
FROM scratch_cards_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $2 OFFSET $3
`

type GetUserScratchCardBetHistoriesParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserScratchCardBetHistoriesRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Status    string
	BetAmount decimal.Decimal
	WonStatus sql.NullString
	Timestamp time.Time
	WonAmount decimal.NullDecimal
	TotalRows int64
}

func (q *Queries) GetUserScratchCardBetHistories(ctx context.Context, arg GetUserScratchCardBetHistoriesParams) ([]GetUserScratchCardBetHistoriesRow, error) {
	rows, err := q.db.Query(ctx, getUserScratchCardBetHistories, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserScratchCardBetHistoriesRow
	for rows.Next() {
		var i GetUserScratchCardBetHistoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Status,
			&i.BetAmount,
			&i.WonStatus,
			&i.Timestamp,
			&i.WonAmount,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

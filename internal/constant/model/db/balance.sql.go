// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: balance.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const balanceExist = `-- name: BalanceExist :one
SELECT EXISTS (
    SELECT 1 
    FROM balances 
    WHERE user_id = $1 AND currency_code = $2
) AS exists
`

type BalanceExistParams struct {
	UserID       uuid.UUID
	CurrencyCode string
}

func (q *Queries) BalanceExist(ctx context.Context, arg BalanceExistParams) (bool, error) {
	row := q.db.QueryRow(ctx, balanceExist, arg.UserID, arg.CurrencyCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createBalance = `-- name: CreateBalance :one
INSERT INTO balances(user_id,currency_code,amount_cents,amount_units,reserved_cents,reserved_units,updated_at) VALUES 
($1,$2,$3,$4,$5,$6,$7) RETURNING id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at
`

type CreateBalanceParams struct {
	UserID        uuid.UUID
	CurrencyCode  string
	AmountCents   int64
	AmountUnits   decimal.Decimal
	ReservedCents int64
	ReservedUnits decimal.Decimal
	UpdatedAt     time.Time
}

func (q *Queries) CreateBalance(ctx context.Context, arg CreateBalanceParams) (Balance, error) {
	row := q.db.QueryRow(ctx, createBalance,
		arg.UserID,
		arg.CurrencyCode,
		arg.AmountCents,
		arg.AmountUnits,
		arg.ReservedCents,
		arg.ReservedUnits,
		arg.UpdatedAt,
	)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyCode,
		&i.AmountCents,
		&i.AmountUnits,
		&i.ReservedCents,
		&i.ReservedUnits,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserBalanaceByUserIDAndCurrency = `-- name: GetUserBalanaceByUserIDAndCurrency :one
SELECT id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at FROM balances where user_id = $1 and currency_code=$2
`

type GetUserBalanaceByUserIDAndCurrencyParams struct {
	UserID       uuid.UUID
	CurrencyCode string
}

func (q *Queries) GetUserBalanaceByUserIDAndCurrency(ctx context.Context, arg GetUserBalanaceByUserIDAndCurrencyParams) (Balance, error) {
	row := q.db.QueryRow(ctx, getUserBalanaceByUserIDAndCurrency, arg.UserID, arg.CurrencyCode)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyCode,
		&i.AmountCents,
		&i.AmountUnits,
		&i.ReservedCents,
		&i.ReservedUnits,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserBalancesByUserID = `-- name: GetUserBalancesByUserID :many
SELECT id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at FROM  balances where user_id = $1
`

func (q *Queries) GetUserBalancesByUserID(ctx context.Context, userID uuid.UUID) ([]Balance, error) {
	rows, err := q.db.Query(ctx, getUserBalancesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Balance
	for rows.Next() {
		var i Balance
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CurrencyCode,
			&i.AmountCents,
			&i.AmountUnits,
			&i.ReservedCents,
			&i.ReservedUnits,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockBalance = `-- name: LockBalance :one
SELECT id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at FROM balances 
WHERE user_id = $1 and currency_code = $2
FOR UPDATE
`

type LockBalanceParams struct {
	UserID       uuid.UUID
	CurrencyCode string
}

func (q *Queries) LockBalance(ctx context.Context, arg LockBalanceParams) (Balance, error) {
	row := q.db.QueryRow(ctx, lockBalance, arg.UserID, arg.CurrencyCode)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyCode,
		&i.AmountCents,
		&i.AmountUnits,
		&i.ReservedCents,
		&i.ReservedUnits,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAmountUnits = `-- name: UpdateAmountUnits :one
UPDATE balances set amount_units = $1, reserved_units = $2, updated_at=$3 where user_id = $4 and currency_code = $5
RETURNING id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at
`

type UpdateAmountUnitsParams struct {
	AmountUnits   decimal.Decimal
	ReservedUnits decimal.Decimal
	UpdatedAt     time.Time
	UserID        uuid.UUID
	CurrencyCode  string
}

func (q *Queries) UpdateAmountUnits(ctx context.Context, arg UpdateAmountUnitsParams) (Balance, error) {
	row := q.db.QueryRow(ctx, updateAmountUnits,
		arg.AmountUnits,
		arg.ReservedUnits,
		arg.UpdatedAt,
		arg.UserID,
		arg.CurrencyCode,
	)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyCode,
		&i.AmountCents,
		&i.AmountUnits,
		&i.ReservedCents,
		&i.ReservedUnits,
		&i.UpdatedAt,
	)
	return i, err
}

const updateBalance = `-- name: UpdateBalance :one
UPDATE balances set currency_code = $1,amount_units=$2,reserved_units=$3,reserved_cents=$4,updated_at=$5 where user_id = $6
RETURNING id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at
`

type UpdateBalanceParams struct {
	CurrencyCode  string
	AmountUnits   decimal.Decimal
	ReservedUnits decimal.Decimal
	ReservedCents int32
	UpdatedAt     time.Time
	UserID        uuid.UUID
}

func (q *Queries) UpdateBalance(ctx context.Context, arg UpdateBalanceParams) (Balance, error) {
	row := q.db.QueryRow(ctx, updateBalance,
		arg.CurrencyCode,
		arg.AmountUnits,
		arg.ReservedUnits,
		arg.ReservedCents,
		arg.UpdatedAt,
		arg.UserID,
	)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyCode,
		&i.AmountCents,
		&i.AmountUnits,
		&i.ReservedCents,
		&i.ReservedUnits,
		&i.UpdatedAt,
	)
	return i, err
}

const updateReservedUnits = `-- name: UpdateReservedUnits :one
UPDATE balances set reserved_cents = $1, updated_at=$2 where user_id = $3 and currency_code = $4
RETURNING id, user_id, currency_code, amount_cents, amount_units, reserved_cents, reserved_units, updated_at
`

type UpdateReservedUnitsParams struct {
	ReservedCents int32
	UpdatedAt     time.Time
	UserID        uuid.UUID
	CurrencyCode  string
}

func (q *Queries) UpdateReservedUnits(ctx context.Context, arg UpdateReservedUnitsParams) (Balance, error) {
	row := q.db.QueryRow(ctx, updateReservedUnits,
		arg.ReservedCents,
		arg.UpdatedAt,
		arg.UserID,
		arg.CurrencyCode,
	)
	var i Balance
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CurrencyCode,
		&i.AmountCents,
		&i.AmountUnits,
		&i.ReservedCents,
		&i.ReservedUnits,
		&i.UpdatedAt,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: departements.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const assignUserToDepartment = `-- name: AssignUserToDepartment :one
INSERT INTO departements_users (user_id,department_id) values (
$1,$2
) RETURNING id, user_id, department_id, created_at
`

type AssignUserToDepartmentParams struct {
	UserID       uuid.UUID
	DepartmentID uuid.UUID
}

func (q *Queries) AssignUserToDepartment(ctx context.Context, arg AssignUserToDepartmentParams) (DepartementsUser, error) {
	row := q.db.QueryRow(ctx, assignUserToDepartment, arg.UserID, arg.DepartmentID)
	var i DepartementsUser
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DepartmentID,
		&i.CreatedAt,
	)
	return i, err
}

const createDepartment = `-- name: CreateDepartment :one
INSERT INTO departments (name,notifications,created_at) VALUES ($1,$2,$3)
RETURNING id, name, notifications, created_at
`

type CreateDepartmentParams struct {
	Name          string
	Notifications []string
	CreatedAt     sql.NullTime
}

func (q *Queries) CreateDepartment(ctx context.Context, arg CreateDepartmentParams) (Department, error) {
	row := q.db.QueryRow(ctx, createDepartment, arg.Name, arg.Notifications, arg.CreatedAt)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Notifications,
		&i.CreatedAt,
	)
	return i, err
}

const getAllDepatments = `-- name: GetAllDepatments :many
SELECT id, name, notifications, created_at,count(*) as total FROM departments where true GROUP BY id limit $1 offset $2
`

type GetAllDepatmentsParams struct {
	Limit  int32
	Offset int32
}

type GetAllDepatmentsRow struct {
	ID            uuid.UUID
	Name          string
	Notifications []string
	CreatedAt     sql.NullTime
	Total         int64
}

func (q *Queries) GetAllDepatments(ctx context.Context, arg GetAllDepatmentsParams) ([]GetAllDepatmentsRow, error) {
	rows, err := q.db.Query(ctx, getAllDepatments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDepatmentsRow
	for rows.Next() {
		var i GetAllDepatmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Notifications,
			&i.CreatedAt,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDepartementByID = `-- name: GetDepartementByID :one
SELECT id, name, notifications, created_at FROM departments where id = $1
`

func (q *Queries) GetDepartementByID(ctx context.Context, id uuid.UUID) (Department, error) {
	row := q.db.QueryRow(ctx, getDepartementByID, id)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Notifications,
		&i.CreatedAt,
	)
	return i, err
}

const getDepartementByName = `-- name: GetDepartementByName :one
SELECT id, name, notifications, created_at FROM departments where name = $1
`

func (q *Queries) GetDepartementByName(ctx context.Context, name string) (Department, error) {
	row := q.db.QueryRow(ctx, getDepartementByName, name)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Notifications,
		&i.CreatedAt,
	)
	return i, err
}

const getUserDepartmentByID = `-- name: GetUserDepartmentByID :many
SELECT dep.name, dep.notifications, dep.id AS department_id,
       usr.id AS user_id, usr.first_name, usr.last_name, usr.username, usr.email
FROM departments dep
JOIN departements_users dpu ON dep.id = dpu.department_id
JOIN users usr ON usr.id = dpu.user_id
WHERE usr.id = $1
`

type GetUserDepartmentByIDRow struct {
	Name          string
	Notifications []string
	DepartmentID  uuid.UUID
	UserID        uuid.UUID
	FirstName     sql.NullString
	LastName      sql.NullString
	Username      sql.NullString
	Email         sql.NullString
}

func (q *Queries) GetUserDepartmentByID(ctx context.Context, id uuid.UUID) ([]GetUserDepartmentByIDRow, error) {
	rows, err := q.db.Query(ctx, getUserDepartmentByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserDepartmentByIDRow
	for rows.Next() {
		var i GetUserDepartmentByIDRow
		if err := rows.Scan(
			&i.Name,
			&i.Notifications,
			&i.DepartmentID,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDepartments = `-- name: UpdateDepartments :one
UPDATE departments SET name = $1,notifications = $2 WHERE id = $3 RETURNING id, name, notifications, created_at
`

type UpdateDepartmentsParams struct {
	Name          string
	Notifications []string
	ID            uuid.UUID
}

func (q *Queries) UpdateDepartments(ctx context.Context, arg UpdateDepartmentsParams) (Department, error) {
	row := q.db.QueryRow(ctx, updateDepartments, arg.Name, arg.Notifications, arg.ID)
	var i Department
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Notifications,
		&i.CreatedAt,
	)
	return i, err
}

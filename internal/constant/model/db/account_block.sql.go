// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account_block.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const blockAccount = `-- name: BlockAccount :one
INSERT INTO account_block (user_id,blocked_by,duration,blocked_from,blocked_to,unblocked_at,reason,created_at,type,note) 
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING id, user_id, blocked_by, duration, type, blocked_from, blocked_to, unblocked_at, reason, note, created_at
`

type BlockAccountParams struct {
	UserID      uuid.UUID
	BlockedBy   uuid.UUID
	Duration    string
	BlockedFrom sql.NullTime
	BlockedTo   sql.NullTime
	UnblockedAt sql.NullTime
	Reason      sql.NullString
	CreatedAt   sql.NullTime
	Type        string
	Note        sql.NullString
}

func (q *Queries) BlockAccount(ctx context.Context, arg BlockAccountParams) (AccountBlock, error) {
	row := q.db.QueryRow(ctx, blockAccount,
		arg.UserID,
		arg.BlockedBy,
		arg.Duration,
		arg.BlockedFrom,
		arg.BlockedTo,
		arg.UnblockedAt,
		arg.Reason,
		arg.CreatedAt,
		arg.Type,
		arg.Note,
	)
	var i AccountBlock
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BlockedBy,
		&i.Duration,
		&i.Type,
		&i.BlockedFrom,
		&i.BlockedTo,
		&i.UnblockedAt,
		&i.Reason,
		&i.Note,
		&i.CreatedAt,
	)
	return i, err
}

const createIPFilter = `-- name: CreateIPFilter :one
INSERT INTO ip_filters(created_by,start_ip,end_ip,type,created_at,description) VALUES(
    $1,$2,$3,$4,$5,$6
) RETURNING id, created_by, start_ip, end_ip, type, created_at, description, hits, last_hit
`

type CreateIPFilterParams struct {
	CreatedBy   uuid.UUID
	StartIp     string
	EndIp       string
	Type        string
	CreatedAt   sql.NullTime
	Description string
}

func (q *Queries) CreateIPFilter(ctx context.Context, arg CreateIPFilterParams) (IpFilter, error) {
	row := q.db.QueryRow(ctx, createIPFilter,
		arg.CreatedBy,
		arg.StartIp,
		arg.EndIp,
		arg.Type,
		arg.CreatedAt,
		arg.Description,
	)
	var i IpFilter
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.StartIp,
		&i.EndIp,
		&i.Type,
		&i.CreatedAt,
		&i.Description,
		&i.Hits,
		&i.LastHit,
	)
	return i, err
}

const getAccountBlockByUserID = `-- name: GetAccountBlockByUserID :many
SELECT id, user_id, blocked_by, duration, type, blocked_from, blocked_to, unblocked_at, reason, note, created_at FROM account_block where user_id =$1 and unblocked_at is null
`

func (q *Queries) GetAccountBlockByUserID(ctx context.Context, userID uuid.UUID) ([]AccountBlock, error) {
	rows, err := q.db.Query(ctx, getAccountBlockByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AccountBlock
	for rows.Next() {
		var i AccountBlock
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllIpFilterWithLimitAndOffset = `-- name: GetAllIpFilterWithLimitAndOffset :many
SELECT ipf.id, ipf.created_by, start_ip, end_ip, type, ipf.created_at, description, hits, last_hit, us.id, username, phone_number, password, us.created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, us.created_by, is_admin, status, referal_type, refered_by_code, user_type,us.id as user_id,us.first_name,us.last_name,us.email,count(*) as total  FROM ip_filters ipf JOIN users us ON ipf.created_by = us.id where  true GROUP BY ipf.id,us.id limit $1 offset $2
`

type GetAllIpFilterWithLimitAndOffsetParams struct {
	Limit  int32
	Offset int32
}

type GetAllIpFilterWithLimitAndOffsetRow struct {
	ID              uuid.UUID
	CreatedBy       uuid.UUID
	StartIp         string
	EndIp           string
	Type            string
	CreatedAt       sql.NullTime
	Description     string
	Hits            int32
	LastHit         sql.NullTime
	ID_2            uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt_2     time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy_2     uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	UserID          uuid.UUID
	FirstName_2     sql.NullString
	LastName_2      sql.NullString
	Email_2         sql.NullString
	Total           int64
}

func (q *Queries) GetAllIpFilterWithLimitAndOffset(ctx context.Context, arg GetAllIpFilterWithLimitAndOffsetParams) ([]GetAllIpFilterWithLimitAndOffsetRow, error) {
	rows, err := q.db.Query(ctx, getAllIpFilterWithLimitAndOffset, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllIpFilterWithLimitAndOffsetRow
	for rows.Next() {
		var i GetAllIpFilterWithLimitAndOffsetRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.StartIp,
			&i.EndIp,
			&i.Type,
			&i.CreatedAt,
			&i.Description,
			&i.Hits,
			&i.LastHit,
			&i.ID_2,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt_2,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy_2,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.UserID,
			&i.FirstName_2,
			&i.LastName_2,
			&i.Email_2,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAccountByUserID = `-- name: GetBlockedAccountByUserID :many
   SELECT 
    ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blockde_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    WHERE user_id = $1
    ORDER BY ab.id 
	Limit $2 offset $3
`

type GetBlockedAccountByUserIDParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetBlockedAccountByUserIDRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockdeAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAccountByUserID(ctx context.Context, arg GetBlockedAccountByUserIDParams) ([]GetBlockedAccountByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAccountByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAccountByUserIDRow
	for rows.Next() {
		var i GetBlockedAccountByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockdeAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAccountByUserIDAndDuration = `-- name: GetBlockedAccountByUserIDAndDuration :many
   SELECT 
    ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blockde_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    WHERE user_id = $1 and duration = $2
    ORDER BY ab.id 
	Limit $3 offset $4
`

type GetBlockedAccountByUserIDAndDurationParams struct {
	UserID   uuid.UUID
	Duration string
	Limit    int32
	Offset   int32
}

type GetBlockedAccountByUserIDAndDurationRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockdeAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAccountByUserIDAndDuration(ctx context.Context, arg GetBlockedAccountByUserIDAndDurationParams) ([]GetBlockedAccountByUserIDAndDurationRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAccountByUserIDAndDuration,
		arg.UserID,
		arg.Duration,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAccountByUserIDAndDurationRow
	for rows.Next() {
		var i GetBlockedAccountByUserIDAndDurationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockdeAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAccountByUserIDAndType = `-- name: GetBlockedAccountByUserIDAndType :many
   SELECT 
    ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blockde_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    WHERE user_id = $1 and type = $2
    ORDER BY ab.id 
	Limit $3 offset $4
`

type GetBlockedAccountByUserIDAndTypeParams struct {
	UserID uuid.UUID
	Type   string
	Limit  int32
	Offset int32
}

type GetBlockedAccountByUserIDAndTypeRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockdeAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAccountByUserIDAndType(ctx context.Context, arg GetBlockedAccountByUserIDAndTypeParams) ([]GetBlockedAccountByUserIDAndTypeRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAccountByUserIDAndType,
		arg.UserID,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAccountByUserIDAndTypeRow
	for rows.Next() {
		var i GetBlockedAccountByUserIDAndTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockdeAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAllAccount = `-- name: GetBlockedAllAccount :many
   SELECT 
     ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blockde_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    ORDER BY ab.id
	Limit $1 offset $2
`

type GetBlockedAllAccountParams struct {
	Limit  int32
	Offset int32
}

type GetBlockedAllAccountRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockdeAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAllAccount(ctx context.Context, arg GetBlockedAllAccountParams) ([]GetBlockedAllAccountRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAllAccount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAllAccountRow
	for rows.Next() {
		var i GetBlockedAllAccountRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockdeAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAllAccountByDuration = `-- name: GetBlockedAllAccountByDuration :many
   SELECT 
     ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blockde_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    WHERE duration = $1
    ORDER BY ab.id
	Limit $2 offset $3
`

type GetBlockedAllAccountByDurationParams struct {
	Duration string
	Limit    int32
	Offset   int32
}

type GetBlockedAllAccountByDurationRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockdeAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAllAccountByDuration(ctx context.Context, arg GetBlockedAllAccountByDurationParams) ([]GetBlockedAllAccountByDurationRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAllAccountByDuration, arg.Duration, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAllAccountByDurationRow
	for rows.Next() {
		var i GetBlockedAllAccountByDurationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockdeAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAllAccountByType = `-- name: GetBlockedAllAccountByType :many
   SELECT 
     ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blockde_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    WHERE type = $1
    ORDER BY ab.id
	Limit $2 offset $3
`

type GetBlockedAllAccountByTypeParams struct {
	Type   string
	Limit  int32
	Offset int32
}

type GetBlockedAllAccountByTypeRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockdeAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAllAccountByType(ctx context.Context, arg GetBlockedAllAccountByTypeParams) ([]GetBlockedAllAccountByTypeRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAllAccountByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAllAccountByTypeRow
	for rows.Next() {
		var i GetBlockedAllAccountByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockdeAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAllAccountByTypeAndDuration = `-- name: GetBlockedAllAccountByTypeAndDuration :many
   SELECT 
     ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blockde_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    WHERE duration = $1 AND type = $2
    ORDER BY ab.id
	Limit $3 offset $4
`

type GetBlockedAllAccountByTypeAndDurationParams struct {
	Duration string
	Type     string
	Limit    int32
	Offset   int32
}

type GetBlockedAllAccountByTypeAndDurationRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockdeAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAllAccountByTypeAndDuration(ctx context.Context, arg GetBlockedAllAccountByTypeAndDurationParams) ([]GetBlockedAllAccountByTypeAndDurationRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAllAccountByTypeAndDuration,
		arg.Duration,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAllAccountByTypeAndDurationRow
	for rows.Next() {
		var i GetBlockedAllAccountByTypeAndDurationRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockdeAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockedAllAccountByTypeAndDurationAndUserID = `-- name: GetBlockedAllAccountByTypeAndDurationAndUserID :many
   SELECT 
     ab.id, ab.user_id, ab.blocked_by, ab.duration, ab.type, ab.blocked_from, ab.blocked_to, ab.unblocked_at, ab.reason, ab.note, ab.created_at, 
    acuser.id AS blocked_account_user_id, 
    acuser.phone_number AS blocked_account_user_phone, 
    acuser.email AS blocked_account_user_email,
    acuser.first_name AS blocked_account_user_first_name,
    acuser.last_name AS blocked_account_user_last_name,
    acuser.username AS blocked_account_user_username,

	blockerAcc.id AS blocker_account_user_id, 
    blockerAcc.phone_number AS blocker_account_user_phone, 
    blockerAcc.email AS blocker_account_user_email,
    blockerAcc.first_name AS blocker_account_user_first_name,
    blockerAcc.last_name AS blocker_account_user_last_name,
    blockerAcc.username AS blocker_account_user_username,
    COUNT(*) OVER() AS total

FROM 
    account_block ab
JOIN 
    users acuser 
    ON ab.user_id = acuser.id
JOIN 
    users blockerAcc 
    ON ab.blocked_by = blockerAcc.id
    WHERE duration = $1 AND type = $2 and user_id = $3
    ORDER BY ab.id
	Limit $4 offset $5
`

type GetBlockedAllAccountByTypeAndDurationAndUserIDParams struct {
	Duration string
	Type     string
	UserID   uuid.UUID
	Limit    int32
	Offset   int32
}

type GetBlockedAllAccountByTypeAndDurationAndUserIDRow struct {
	ID                          uuid.UUID
	UserID                      uuid.UUID
	BlockedBy                   uuid.UUID
	Duration                    string
	Type                        string
	BlockedFrom                 sql.NullTime
	BlockedTo                   sql.NullTime
	UnblockedAt                 sql.NullTime
	Reason                      sql.NullString
	Note                        sql.NullString
	CreatedAt                   sql.NullTime
	BlockedAccountUserID        uuid.UUID
	BlockedAccountUserPhone     sql.NullString
	BlockedAccountUserEmail     sql.NullString
	BlockedAccountUserFirstName sql.NullString
	BlockedAccountUserLastName  sql.NullString
	BlockedAccountUserUsername  sql.NullString
	BlockerAccountUserID        uuid.UUID
	BlockerAccountUserPhone     sql.NullString
	BlockerAccountUserEmail     sql.NullString
	BlockerAccountUserFirstName sql.NullString
	BlockerAccountUserLastName  sql.NullString
	BlockerAccountUserUsername  sql.NullString
	Total                       int64
}

func (q *Queries) GetBlockedAllAccountByTypeAndDurationAndUserID(ctx context.Context, arg GetBlockedAllAccountByTypeAndDurationAndUserIDParams) ([]GetBlockedAllAccountByTypeAndDurationAndUserIDRow, error) {
	rows, err := q.db.Query(ctx, getBlockedAllAccountByTypeAndDurationAndUserID,
		arg.Duration,
		arg.Type,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBlockedAllAccountByTypeAndDurationAndUserIDRow
	for rows.Next() {
		var i GetBlockedAllAccountByTypeAndDurationAndUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.BlockedBy,
			&i.Duration,
			&i.Type,
			&i.BlockedFrom,
			&i.BlockedTo,
			&i.UnblockedAt,
			&i.Reason,
			&i.Note,
			&i.CreatedAt,
			&i.BlockedAccountUserID,
			&i.BlockedAccountUserPhone,
			&i.BlockedAccountUserEmail,
			&i.BlockedAccountUserFirstName,
			&i.BlockedAccountUserLastName,
			&i.BlockedAccountUserUsername,
			&i.BlockerAccountUserID,
			&i.BlockerAccountUserPhone,
			&i.BlockerAccountUserEmail,
			&i.BlockerAccountUserFirstName,
			&i.BlockerAccountUserLastName,
			&i.BlockerAccountUserUsername,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIpFilterByType = `-- name: GetIpFilterByType :many
SELECT ipf.id, ipf.created_by, start_ip, end_ip, type, ipf.created_at, description, hits, last_hit, us.id, username, phone_number, password, us.created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, us.created_by, is_admin, status, referal_type, refered_by_code, user_type,us.id as user_id,us.first_name,us.last_name,us.email,count(*) as total FROM ip_filters ipf JOIN users us ON ipf.created_by = us.id where type = $1 GROUP BY ipf.id,us.id
`

type GetIpFilterByTypeRow struct {
	ID              uuid.UUID
	CreatedBy       uuid.UUID
	StartIp         string
	EndIp           string
	Type            string
	CreatedAt       sql.NullTime
	Description     string
	Hits            int32
	LastHit         sql.NullTime
	ID_2            uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt_2     time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy_2     uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	UserID          uuid.UUID
	FirstName_2     sql.NullString
	LastName_2      sql.NullString
	Email_2         sql.NullString
	Total           int64
}

func (q *Queries) GetIpFilterByType(ctx context.Context, type_ string) ([]GetIpFilterByTypeRow, error) {
	rows, err := q.db.Query(ctx, getIpFilterByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIpFilterByTypeRow
	for rows.Next() {
		var i GetIpFilterByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.StartIp,
			&i.EndIp,
			&i.Type,
			&i.CreatedAt,
			&i.Description,
			&i.Hits,
			&i.LastHit,
			&i.ID_2,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt_2,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy_2,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.UserID,
			&i.FirstName_2,
			&i.LastName_2,
			&i.Email_2,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIpFilterByTypeWithLimitAndOffset = `-- name: GetIpFilterByTypeWithLimitAndOffset :many
SELECT ipf.id, ipf.created_by, start_ip, end_ip, type, ipf.created_at, description, hits, last_hit, us.id, username, phone_number, password, us.created_at, default_currency, profile, email, first_name, last_name, date_of_birth, source, referal_code, street_address, country, state, city, postal_code, kyc_status, us.created_by, is_admin, status, referal_type, refered_by_code, user_type,us.id as user_id,us.first_name,us.last_name,us.email,count(*) as total  FROM ip_filters ipf JOIN users us ON ipf.created_by = us.id where type = $1 GROUP BY ipf.id,us.id limit $2 offset $3
`

type GetIpFilterByTypeWithLimitAndOffsetParams struct {
	Type   string
	Limit  int32
	Offset int32
}

type GetIpFilterByTypeWithLimitAndOffsetRow struct {
	ID              uuid.UUID
	CreatedBy       uuid.UUID
	StartIp         string
	EndIp           string
	Type            string
	CreatedAt       sql.NullTime
	Description     string
	Hits            int32
	LastHit         sql.NullTime
	ID_2            uuid.UUID
	Username        sql.NullString
	PhoneNumber     sql.NullString
	Password        string
	CreatedAt_2     time.Time
	DefaultCurrency sql.NullString
	Profile         sql.NullString
	Email           sql.NullString
	FirstName       sql.NullString
	LastName        sql.NullString
	DateOfBirth     sql.NullString
	Source          sql.NullString
	ReferalCode     sql.NullString
	StreetAddress   string
	Country         string
	State           string
	City            string
	PostalCode      string
	KycStatus       string
	CreatedBy_2     uuid.NullUUID
	IsAdmin         sql.NullBool
	Status          sql.NullString
	ReferalType     sql.NullString
	ReferedByCode   sql.NullString
	UserType        sql.NullString
	UserID          uuid.UUID
	FirstName_2     sql.NullString
	LastName_2      sql.NullString
	Email_2         sql.NullString
	Total           int64
}

func (q *Queries) GetIpFilterByTypeWithLimitAndOffset(ctx context.Context, arg GetIpFilterByTypeWithLimitAndOffsetParams) ([]GetIpFilterByTypeWithLimitAndOffsetRow, error) {
	rows, err := q.db.Query(ctx, getIpFilterByTypeWithLimitAndOffset, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIpFilterByTypeWithLimitAndOffsetRow
	for rows.Next() {
		var i GetIpFilterByTypeWithLimitAndOffsetRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.StartIp,
			&i.EndIp,
			&i.Type,
			&i.CreatedAt,
			&i.Description,
			&i.Hits,
			&i.LastHit,
			&i.ID_2,
			&i.Username,
			&i.PhoneNumber,
			&i.Password,
			&i.CreatedAt_2,
			&i.DefaultCurrency,
			&i.Profile,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Source,
			&i.ReferalCode,
			&i.StreetAddress,
			&i.Country,
			&i.State,
			&i.City,
			&i.PostalCode,
			&i.KycStatus,
			&i.CreatedBy_2,
			&i.IsAdmin,
			&i.Status,
			&i.ReferalType,
			&i.ReferedByCode,
			&i.UserType,
			&i.UserID,
			&i.FirstName_2,
			&i.LastName_2,
			&i.Email_2,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIpFiltersByID = `-- name: GetIpFiltersByID :one
SELECT id, created_by, start_ip, end_ip, type, created_at, description, hits, last_hit FROM ip_filters where id = $1
`

func (q *Queries) GetIpFiltersByID(ctx context.Context, id uuid.UUID) (IpFilter, error) {
	row := q.db.QueryRow(ctx, getIpFiltersByID, id)
	var i IpFilter
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.StartIp,
		&i.EndIp,
		&i.Type,
		&i.CreatedAt,
		&i.Description,
		&i.Hits,
		&i.LastHit,
	)
	return i, err
}

const getPermamentlyBlockedAccountByUserIdAndType = `-- name: GetPermamentlyBlockedAccountByUserIdAndType :one
SELECT id, user_id, blocked_by, duration, type, blocked_from, blocked_to, unblocked_at, reason, note, created_at FROM account_block where user_id = $1 and type = $2 and duration = $3 and unblocked_at is null
`

type GetPermamentlyBlockedAccountByUserIdAndTypeParams struct {
	UserID   uuid.UUID
	Type     string
	Duration string
}

func (q *Queries) GetPermamentlyBlockedAccountByUserIdAndType(ctx context.Context, arg GetPermamentlyBlockedAccountByUserIdAndTypeParams) (AccountBlock, error) {
	row := q.db.QueryRow(ctx, getPermamentlyBlockedAccountByUserIdAndType, arg.UserID, arg.Type, arg.Duration)
	var i AccountBlock
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BlockedBy,
		&i.Duration,
		&i.Type,
		&i.BlockedFrom,
		&i.BlockedTo,
		&i.UnblockedAt,
		&i.Reason,
		&i.Note,
		&i.CreatedAt,
	)
	return i, err
}

const removeAccountBlock = `-- name: RemoveAccountBlock :exec
DELETE FROM ip_filters where id =$1
`

func (q *Queries) RemoveAccountBlock(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, removeAccountBlock, id)
	return err
}

const unlockAccount = `-- name: UnlockAccount :one
UPDATE account_block set unblocked_at = now() where id = $1 RETURNING id, user_id, blocked_by, duration, type, blocked_from, blocked_to, unblocked_at, reason, note, created_at
`

func (q *Queries) UnlockAccount(ctx context.Context, id uuid.UUID) (AccountBlock, error) {
	row := q.db.QueryRow(ctx, unlockAccount, id)
	var i AccountBlock
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.BlockedBy,
		&i.Duration,
		&i.Type,
		&i.BlockedFrom,
		&i.BlockedTo,
		&i.UnblockedAt,
		&i.Reason,
		&i.Note,
		&i.CreatedAt,
	)
	return i, err
}

const updateIPfilter = `-- name: UpdateIPfilter :one
UPDATE ip_filters  set description = $1,hits = $2 ,last_hit = $3 where id = $4 RETURNING id, created_by, start_ip, end_ip, type, created_at, description, hits, last_hit
`

type UpdateIPfilterParams struct {
	Description string
	Hits        int32
	LastHit     sql.NullTime
	ID          uuid.UUID
}

func (q *Queries) UpdateIPfilter(ctx context.Context, arg UpdateIPfilterParams) (IpFilter, error) {
	row := q.db.QueryRow(ctx, updateIPfilter,
		arg.Description,
		arg.Hits,
		arg.LastHit,
		arg.ID,
	)
	var i IpFilter
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.StartIp,
		&i.EndIp,
		&i.Type,
		&i.CreatedAt,
		&i.Description,
		&i.Hits,
		&i.LastHit,
	)
	return i, err
}

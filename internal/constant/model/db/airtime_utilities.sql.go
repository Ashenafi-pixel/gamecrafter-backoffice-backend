// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: airtime_utilities.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const createAirtimeUtiles = `-- name: CreateAirtimeUtiles :one
INSERT INTO airtime_utilities (id,productName,billerName,amount,isAmountFixed,status,timestamp,price)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8) RETURNING local_id, id, productname, billername, amount, isamountfixed, price, status, timestamp
`

type CreateAirtimeUtilesParams struct {
	ID            int32
	Productname   string
	Billername    string
	Amount        string
	Isamountfixed bool
	Status        string
	Timestamp     time.Time
	Price         decimal.NullDecimal
}

func (q *Queries) CreateAirtimeUtiles(ctx context.Context, arg CreateAirtimeUtilesParams) (AirtimeUtility, error) {
	row := q.db.QueryRow(ctx, createAirtimeUtiles,
		arg.ID,
		arg.Productname,
		arg.Billername,
		arg.Amount,
		arg.Isamountfixed,
		arg.Status,
		arg.Timestamp,
		arg.Price,
	)
	var i AirtimeUtility
	err := row.Scan(
		&i.LocalID,
		&i.ID,
		&i.Productname,
		&i.Billername,
		&i.Amount,
		&i.Isamountfixed,
		&i.Price,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const getActiveAvailableAirtime = `-- name: GetActiveAvailableAirtime :many
WITH airtime_utilities_data AS (
    SELECT local_id, id, productname, billername, amount, isamountfixed, price, status, timestamp
    FROM airtime_utilities WHERE status = 'ACTIVE'
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM airtime_utilities_data
)
SELECT c.local_id, c.id, c.productname, c.billername, c.amount, c.isamountfixed, c.price, c.status, c.timestamp, r.total_rows
FROM airtime_utilities_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $1 OFFSET $2
`

type GetActiveAvailableAirtimeParams struct {
	Limit  int32
	Offset int32
}

type GetActiveAvailableAirtimeRow struct {
	LocalID       uuid.UUID
	ID            int32
	Productname   string
	Billername    string
	Amount        string
	Isamountfixed bool
	Price         decimal.NullDecimal
	Status        string
	Timestamp     time.Time
	TotalRows     int64
}

func (q *Queries) GetActiveAvailableAirtime(ctx context.Context, arg GetActiveAvailableAirtimeParams) ([]GetActiveAvailableAirtimeRow, error) {
	rows, err := q.db.Query(ctx, getActiveAvailableAirtime, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveAvailableAirtimeRow
	for rows.Next() {
		var i GetActiveAvailableAirtimeRow
		if err := rows.Scan(
			&i.LocalID,
			&i.ID,
			&i.Productname,
			&i.Billername,
			&i.Amount,
			&i.Isamountfixed,
			&i.Price,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAirtimeUtilitiesByID = `-- name: GetAirtimeUtilitiesByID :one
SELECT local_id, id, productname, billername, amount, isamountfixed, price, status, timestamp FROM airtime_utilities where local_id = $1
`

func (q *Queries) GetAirtimeUtilitiesByID(ctx context.Context, localID uuid.UUID) (AirtimeUtility, error) {
	row := q.db.QueryRow(ctx, getAirtimeUtilitiesByID, localID)
	var i AirtimeUtility
	err := row.Scan(
		&i.LocalID,
		&i.ID,
		&i.Productname,
		&i.Billername,
		&i.Amount,
		&i.Isamountfixed,
		&i.Price,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const getAirtimeUtilitiesStats = `-- name: GetAirtimeUtilitiesStats :one
SELECT 
    COUNT(*)::int AS total,
    COALESCE(SUM(CASE WHEN au.status = 'ACTIVE' THEN 1 ELSE 0 END), 0)::int AS active_utilities,
    COALESCE(SUM(at.amount), 0)::decimal AS total_spend_bucks,
	COALESCE(SUM(at.cashout), 0)::decimal AS total_redemptions,
    COALESCE(SUM(CASE WHEN au.status = 'INACTIVE' THEN 1 ELSE 0 END), 0)::int AS inactive_utilities
FROM airtime_utilities au
LEFT JOIN airtime_transactions at ON au.id = at.utilityPackageId
`

type GetAirtimeUtilitiesStatsRow struct {
	Total             int32
	ActiveUtilities   int32
	TotalSpendBucks   decimal.Decimal
	TotalRedemptions  decimal.Decimal
	InactiveUtilities int32
}

func (q *Queries) GetAirtimeUtilitiesStats(ctx context.Context) (GetAirtimeUtilitiesStatsRow, error) {
	row := q.db.QueryRow(ctx, getAirtimeUtilitiesStats)
	var i GetAirtimeUtilitiesStatsRow
	err := row.Scan(
		&i.Total,
		&i.ActiveUtilities,
		&i.TotalSpendBucks,
		&i.TotalRedemptions,
		&i.InactiveUtilities,
	)
	return i, err
}

const getAllAitimeTransactions = `-- name: GetAllAitimeTransactions :many
WITH transaction_data AS (
    SELECT id, user_id, transaction_id, cashout, billername, utilitypackageid, packagename, amount, status, timestamp
    FROM airtime_transactions
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM transaction_data
)
SELECT c.id, c.user_id, c.transaction_id, c.cashout, c.billername, c.utilitypackageid, c.packagename, c.amount, c.status, c.timestamp, r.total_rows
FROM transaction_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $1 OFFSET $2
`

type GetAllAitimeTransactionsParams struct {
	Limit  int32
	Offset int32
}

type GetAllAitimeTransactionsRow struct {
	ID               uuid.UUID
	UserID           uuid.UUID
	TransactionID    string
	Cashout          decimal.Decimal
	Billername       string
	Utilitypackageid int32
	Packagename      string
	Amount           decimal.Decimal
	Status           string
	Timestamp        time.Time
	TotalRows        int64
}

func (q *Queries) GetAllAitimeTransactions(ctx context.Context, arg GetAllAitimeTransactionsParams) ([]GetAllAitimeTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getAllAitimeTransactions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAitimeTransactionsRow
	for rows.Next() {
		var i GetAllAitimeTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TransactionID,
			&i.Cashout,
			&i.Billername,
			&i.Utilitypackageid,
			&i.Packagename,
			&i.Amount,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUtilities = `-- name: GetAllUtilities :many
SELECT local_id, id, productname, billername, amount, isamountfixed, price, status, timestamp FROM airtime_utilities
`

func (q *Queries) GetAllUtilities(ctx context.Context) ([]AirtimeUtility, error) {
	rows, err := q.db.Query(ctx, getAllUtilities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AirtimeUtility
	for rows.Next() {
		var i AirtimeUtility
		if err := rows.Scan(
			&i.LocalID,
			&i.ID,
			&i.Productname,
			&i.Billername,
			&i.Amount,
			&i.Isamountfixed,
			&i.Price,
			&i.Status,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableAirtime = `-- name: GetAvailableAirtime :many
WITH airtime_utilities_data AS (
    SELECT 
        au.local_id, au.id, au.productname, au.billername, au.amount, au.isamountfixed, au.price, au.status, au.timestamp, COALESCE(SUM(tr.cashout), 0)::decimal as total_redemptions, COALESCE(SUM(tr.amount), 0)::decimal as total_bucks_spent
    FROM airtime_utilities au 
    LEFT JOIN airtime_transactions tr 
        ON au.id = tr.utilityPackageId
    GROUP BY au.id,au.local_id
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM airtime_utilities_data
)
SELECT 
    c.local_id, c.id, c.productname, c.billername, c.amount, c.isamountfixed, c.price, c.status, c.timestamp, c.total_redemptions, c.total_bucks_spent, 
    r.total_rows
FROM airtime_utilities_data c 
CROSS JOIN row_count r  
ORDER BY c.timestamp DESC LIMIT $1 OFFSET $2
`

type GetAvailableAirtimeParams struct {
	Limit  int32
	Offset int32
}

type GetAvailableAirtimeRow struct {
	LocalID          uuid.UUID
	ID               int32
	Productname      string
	Billername       string
	Amount           string
	Isamountfixed    bool
	Price            decimal.NullDecimal
	Status           string
	Timestamp        time.Time
	TotalRedemptions decimal.Decimal
	TotalBucksSpent  decimal.Decimal
	TotalRows        int64
}

func (q *Queries) GetAvailableAirtime(ctx context.Context, arg GetAvailableAirtimeParams) ([]GetAvailableAirtimeRow, error) {
	rows, err := q.db.Query(ctx, getAvailableAirtime, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableAirtimeRow
	for rows.Next() {
		var i GetAvailableAirtimeRow
		if err := rows.Scan(
			&i.LocalID,
			&i.ID,
			&i.Productname,
			&i.Billername,
			&i.Amount,
			&i.Isamountfixed,
			&i.Price,
			&i.Status,
			&i.Timestamp,
			&i.TotalRedemptions,
			&i.TotalBucksSpent,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAitimeTransactions = `-- name: GetUserAitimeTransactions :many
WITH transaction_data AS (
    SELECT id, user_id, transaction_id, cashout, billername, utilitypackageid, packagename, amount, status, timestamp
    FROM airtime_transactions where user_id = $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM transaction_data
)
SELECT c.id, c.user_id, c.transaction_id, c.cashout, c.billername, c.utilitypackageid, c.packagename, c.amount, c.status, c.timestamp, r.total_rows
FROM transaction_data c
CROSS JOIN row_count r
ORDER BY c.timestamp DESC
LIMIT $2 OFFSET $3
`

type GetUserAitimeTransactionsParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserAitimeTransactionsRow struct {
	ID               uuid.UUID
	UserID           uuid.UUID
	TransactionID    string
	Cashout          decimal.Decimal
	Billername       string
	Utilitypackageid int32
	Packagename      string
	Amount           decimal.Decimal
	Status           string
	Timestamp        time.Time
	TotalRows        int64
}

func (q *Queries) GetUserAitimeTransactions(ctx context.Context, arg GetUserAitimeTransactionsParams) ([]GetUserAitimeTransactionsRow, error) {
	rows, err := q.db.Query(ctx, getUserAitimeTransactions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAitimeTransactionsRow
	for rows.Next() {
		var i GetUserAitimeTransactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TransactionID,
			&i.Cashout,
			&i.Billername,
			&i.Utilitypackageid,
			&i.Packagename,
			&i.Amount,
			&i.Status,
			&i.Timestamp,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveAirtimeTransactions = `-- name: SaveAirtimeTransactions :one
INSERT INTO airtime_transactions (user_id,transaction_id,cashout,billerName,utilityPackageId,packageName,amount,status,timestamp)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9) RETURNING id, user_id, transaction_id, cashout, billername, utilitypackageid, packagename, amount, status, timestamp
`

type SaveAirtimeTransactionsParams struct {
	UserID           uuid.UUID
	TransactionID    string
	Cashout          decimal.Decimal
	Billername       string
	Utilitypackageid int32
	Packagename      string
	Amount           decimal.Decimal
	Status           string
	Timestamp        time.Time
}

func (q *Queries) SaveAirtimeTransactions(ctx context.Context, arg SaveAirtimeTransactionsParams) (AirtimeTransaction, error) {
	row := q.db.QueryRow(ctx, saveAirtimeTransactions,
		arg.UserID,
		arg.TransactionID,
		arg.Cashout,
		arg.Billername,
		arg.Utilitypackageid,
		arg.Packagename,
		arg.Amount,
		arg.Status,
		arg.Timestamp,
	)
	var i AirtimeTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TransactionID,
		&i.Cashout,
		&i.Billername,
		&i.Utilitypackageid,
		&i.Packagename,
		&i.Amount,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const updateAirtimeUtilitiesAmount = `-- name: UpdateAirtimeUtilitiesAmount :one
UPDATE airtime_utilities SET amount = $1 where local_id = $2 RETURNING local_id, id, productname, billername, amount, isamountfixed, price, status, timestamp
`

type UpdateAirtimeUtilitiesAmountParams struct {
	Amount  string
	LocalID uuid.UUID
}

func (q *Queries) UpdateAirtimeUtilitiesAmount(ctx context.Context, arg UpdateAirtimeUtilitiesAmountParams) (AirtimeUtility, error) {
	row := q.db.QueryRow(ctx, updateAirtimeUtilitiesAmount, arg.Amount, arg.LocalID)
	var i AirtimeUtility
	err := row.Scan(
		&i.LocalID,
		&i.ID,
		&i.Productname,
		&i.Billername,
		&i.Amount,
		&i.Isamountfixed,
		&i.Price,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const updateAirtimeUtilitiesPrice = `-- name: UpdateAirtimeUtilitiesPrice :one
UPDATE airtime_utilities SET price = $1 where local_id = $2 RETURNING local_id, id, productname, billername, amount, isamountfixed, price, status, timestamp
`

type UpdateAirtimeUtilitiesPriceParams struct {
	Price   decimal.NullDecimal
	LocalID uuid.UUID
}

func (q *Queries) UpdateAirtimeUtilitiesPrice(ctx context.Context, arg UpdateAirtimeUtilitiesPriceParams) (AirtimeUtility, error) {
	row := q.db.QueryRow(ctx, updateAirtimeUtilitiesPrice, arg.Price, arg.LocalID)
	var i AirtimeUtility
	err := row.Scan(
		&i.LocalID,
		&i.ID,
		&i.Productname,
		&i.Billername,
		&i.Amount,
		&i.Isamountfixed,
		&i.Price,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

const updateAirtimeUtilitiesStatus = `-- name: UpdateAirtimeUtilitiesStatus :one
UPDATE airtime_utilities SET status = $1 where local_id = $2 RETURNING local_id, id, productname, billername, amount, isamountfixed, price, status, timestamp
`

type UpdateAirtimeUtilitiesStatusParams struct {
	Status  string
	LocalID uuid.UUID
}

func (q *Queries) UpdateAirtimeUtilitiesStatus(ctx context.Context, arg UpdateAirtimeUtilitiesStatusParams) (AirtimeUtility, error) {
	row := q.db.QueryRow(ctx, updateAirtimeUtilitiesStatus, arg.Status, arg.LocalID)
	var i AirtimeUtility
	err := row.Scan(
		&i.LocalID,
		&i.ID,
		&i.Productname,
		&i.Billername,
		&i.Amount,
		&i.Isamountfixed,
		&i.Price,
		&i.Status,
		&i.Timestamp,
	)
	return i, err
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: levels.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/shopspring/decimal"
)

const addFakeBalanceLog = `-- name: AddFakeBalanceLog :one
INSERT INTO balance_logs (user_id, change_amount, currency, operational_type_id,component)
VALUES ($1, $2, $3, (SELECT id FROM operational_types WHERE name = 'place_bet'), 'real_money')
RETURNING id, user_id, component, currency, change_amount, operational_group_id, operational_type_id, description, timestamp, balance_after_update, transaction_id, status
`

type AddFakeBalanceLogParams struct {
	UserID       uuid.NullUUID
	ChangeAmount decimal.NullDecimal
	Currency     sql.NullString
}

func (q *Queries) AddFakeBalanceLog(ctx context.Context, arg AddFakeBalanceLogParams) (BalanceLog, error) {
	row := q.db.QueryRow(ctx, addFakeBalanceLog, arg.UserID, arg.ChangeAmount, arg.Currency)
	var i BalanceLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Component,
		&i.Currency,
		&i.ChangeAmount,
		&i.OperationalGroupID,
		&i.OperationalTypeID,
		&i.Description,
		&i.Timestamp,
		&i.BalanceAfterUpdate,
		&i.TransactionID,
		&i.Status,
	)
	return i, err
}

const calculateSquadBets = `-- name: CalculateSquadBets :one
SELECT COALESCE(SUM(change_amount), 0)::decimal AS total_bet_amount
FROM balance_logs
WHERE user_id in (SELECT user_id FROM squads_memebers WHERE squad_id = $1 AND deleted_at IS NULL) OR user_id in (SELECT owner FROM squads WHERE id = $1 AND deleted_at IS NULL)
AND operational_type_id = (SELECT id FROM operational_types WHERE name = 'place_bet' LIMIT 1)
AND currency = 'P' and timestamp >= (SELECT created_at FROM squads WHERE id = $1 AND deleted_at IS NULL)
`

func (q *Queries) CalculateSquadBets(ctx context.Context, squadID uuid.UUID) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, calculateSquadBets, squadID)
	var total_bet_amount decimal.Decimal
	err := row.Scan(&total_bet_amount)
	return total_bet_amount, err
}

const calculateUserBets = `-- name: CalculateUserBets :one
SELECT COALESCE(SUM(change_amount), 0)::decimal AS total_bet_amount
FROM balance_logs
WHERE user_id = $1
AND operational_type_id = (SELECT id FROM operational_types WHERE name = 'place_bet' LIMIT 1)
AND currency = 'P'
`

func (q *Queries) CalculateUserBets(ctx context.Context, userID uuid.NullUUID) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, calculateUserBets, userID)
	var total_bet_amount decimal.Decimal
	err := row.Scan(&total_bet_amount)
	return total_bet_amount, err
}

const createLevel = `-- name: CreateLevel :one
INSERT INTO levels (level, created_by, type)
VALUES ($1, $2,$3) RETURNING id, level, created_at, updated_at, deleted_at, created_by, type
`

type CreateLevelParams struct {
	Level     decimal.Decimal
	CreatedBy uuid.UUID
	Type      string
}

func (q *Queries) CreateLevel(ctx context.Context, arg CreateLevelParams) (Level, error) {
	row := q.db.QueryRow(ctx, createLevel, arg.Level, arg.CreatedBy, arg.Type)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.Type,
	)
	return i, err
}

const createLevelRequirement = `-- name: CreateLevelRequirement :one
INSERT INTO level_requirements (level_id, type, value, created_by)
VALUES ($1, $2, $3, $4) RETURNING id, level_id, type, value, created_at, updated_at, deleted_at, created_by
`

type CreateLevelRequirementParams struct {
	LevelID   uuid.UUID
	Type      string
	Value     string
	CreatedBy uuid.UUID
}

func (q *Queries) CreateLevelRequirement(ctx context.Context, arg CreateLevelRequirementParams) (LevelRequirement, error) {
	row := q.db.QueryRow(ctx, createLevelRequirement,
		arg.LevelID,
		arg.Type,
		arg.Value,
		arg.CreatedBy,
	)
	var i LevelRequirement
	err := row.Scan(
		&i.ID,
		&i.LevelID,
		&i.Type,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
	)
	return i, err
}

const deleteLevel = `-- name: DeleteLevel :one
UPDATE levels
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, level, created_at, updated_at, deleted_at, created_by, type
`

func (q *Queries) DeleteLevel(ctx context.Context, id uuid.UUID) (Level, error) {
	row := q.db.QueryRow(ctx, deleteLevel, id)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.Type,
	)
	return i, err
}

const deleteLevelRequirement = `-- name: DeleteLevelRequirement :one
UPDATE level_requirements
SET deleted_at = CURRENT_TIMESTAMP, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 RETURNING id, level_id, type, value, created_at, updated_at, deleted_at, created_by
`

func (q *Queries) DeleteLevelRequirement(ctx context.Context, id uuid.UUID) (LevelRequirement, error) {
	row := q.db.QueryRow(ctx, deleteLevelRequirement, id)
	var i LevelRequirement
	err := row.Scan(
		&i.ID,
		&i.LevelID,
		&i.Type,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getAallRequirementsByLevelID = `-- name: GetAallRequirementsByLevelID :many
WITH requirement_data AS (
    SELECT id, level_id, type, value, created_at, updated_at, deleted_at, created_by
    FROM level_requirements
    WHERE deleted_at IS NULL AND level_id = $1
), row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM requirement_data
)
SELECT l.id, l.level_id, l.type, l.value, l.created_at, l.updated_at, l.deleted_at, l.created_by, r.total_rows
FROM requirement_data l
CROSS JOIN row_count r
ORDER BY l.created_at DESC
`

type GetAallRequirementsByLevelIDRow struct {
	ID        uuid.UUID
	LevelID   uuid.UUID
	Type      string
	Value     string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	CreatedBy uuid.UUID
	TotalRows int64
}

func (q *Queries) GetAallRequirementsByLevelID(ctx context.Context, levelID uuid.UUID) ([]GetAallRequirementsByLevelIDRow, error) {
	rows, err := q.db.Query(ctx, getAallRequirementsByLevelID, levelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAallRequirementsByLevelIDRow
	for rows.Next() {
		var i GetAallRequirementsByLevelIDRow
		if err := rows.Scan(
			&i.ID,
			&i.LevelID,
			&i.Type,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLevels = `-- name: GetAllLevels :many
WITH level_data AS (
    SELECT id, level, created_at, updated_at, deleted_at, created_by, type
    FROM levels
    WHERE deleted_at IS NULL and type = $1
), row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM level_data
)
SELECT l.id, l.level, l.created_at, l.updated_at, l.deleted_at, l.created_by, l.type, r.total_rows
FROM level_data l
CROSS JOIN row_count r
ORDER BY l.created_at DESC
`

type GetAllLevelsRow struct {
	ID        uuid.UUID
	Level     decimal.Decimal
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	CreatedBy uuid.UUID
	Type      string
	TotalRows int64
}

func (q *Queries) GetAllLevels(ctx context.Context, type_ string) ([]GetAllLevelsRow, error) {
	rows, err := q.db.Query(ctx, getAllLevels, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLevelsRow
	for rows.Next() {
		var i GetAllLevelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.Type,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSquadMembersBySquadId = `-- name: GetAllSquadMembersBySquadId :many
WITH squad_members AS (
    SELECT 
        COUNT(*) OVER () AS total,
        sm.id,
        sm.squad_id,
        sm.user_id,
        sm.created_at,
        sm.updated_at,
        sm.deleted_at,
        u.username,
        u.first_name,
        u.last_name,
        u.phone_number
    FROM squads_memebers sm
    JOIN users u ON sm.user_id = u.id
    WHERE sm.squad_id = $1 AND sm.deleted_at IS NULL
)
SELECT total, id, squad_id, user_id, created_at, updated_at, deleted_at, username, first_name, last_name, phone_number
FROM squad_members
ORDER BY created_at DESC
`

type GetAllSquadMembersBySquadIdRow struct {
	Total       int64
	ID          uuid.UUID
	SquadID     uuid.UUID
	UserID      uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	Username    sql.NullString
	FirstName   sql.NullString
	LastName    sql.NullString
	PhoneNumber sql.NullString
}

func (q *Queries) GetAllSquadMembersBySquadId(ctx context.Context, squadID uuid.UUID) ([]GetAllSquadMembersBySquadIdRow, error) {
	rows, err := q.db.Query(ctx, getAllSquadMembersBySquadId, squadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSquadMembersBySquadIdRow
	for rows.Next() {
		var i GetAllSquadMembersBySquadIdRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.SquadID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Username,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevelById = `-- name: GetLevelById :one
SELECT id, level, created_at, updated_at, deleted_at, created_by
FROM levels 
WHERE id = $1 AND deleted_at IS NULL
`

type GetLevelByIdRow struct {
	ID        uuid.UUID
	Level     decimal.Decimal
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	CreatedBy uuid.UUID
}

func (q *Queries) GetLevelById(ctx context.Context, id uuid.UUID) (GetLevelByIdRow, error) {
	row := q.db.QueryRow(ctx, getLevelById, id)
	var i GetLevelByIdRow
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
	)
	return i, err
}

const getLevelRequirements = `-- name: GetLevelRequirements :many
WITH requirement_data AS (
    SELECT id, level_id, type, value, created_at, updated_at, deleted_at, created_by
    FROM level_requirements
    WHERE deleted_at IS NULL
), row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM requirement_data
)
SELECT l.id, l.level_id, l.type, l.value, l.created_at, l.updated_at, l.deleted_at, l.created_by, r.total_rows
FROM requirement_data l
CROSS JOIN row_count r
ORDER BY l.created_at DESC
LIMIT $1 OFFSET $2
`

type GetLevelRequirementsParams struct {
	Limit  int32
	Offset int32
}

type GetLevelRequirementsRow struct {
	ID        uuid.UUID
	LevelID   uuid.UUID
	Type      string
	Value     string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	CreatedBy uuid.UUID
	TotalRows int64
}

func (q *Queries) GetLevelRequirements(ctx context.Context, arg GetLevelRequirementsParams) ([]GetLevelRequirementsRow, error) {
	rows, err := q.db.Query(ctx, getLevelRequirements, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLevelRequirementsRow
	for rows.Next() {
		var i GetLevelRequirementsRow
		if err := rows.Scan(
			&i.ID,
			&i.LevelID,
			&i.Type,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevelRequirementsByLevelID = `-- name: GetLevelRequirementsByLevelID :many
WITH requirement_data AS (
    SELECT id, level_id, type, value, created_at, updated_at, deleted_at, created_by
    FROM level_requirements
    WHERE deleted_at IS NULL AND level_id = $1
), row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM requirement_data
)
SELECT l.id, l.level_id, l.type, l.value, l.created_at, l.updated_at, l.deleted_at, l.created_by, r.total_rows
FROM requirement_data l
CROSS JOIN row_count r
ORDER BY l.created_at DESC
LIMIT $2 OFFSET $3
`

type GetLevelRequirementsByLevelIDParams struct {
	LevelID uuid.UUID
	Limit   int32
	Offset  int32
}

type GetLevelRequirementsByLevelIDRow struct {
	ID        uuid.UUID
	LevelID   uuid.UUID
	Type      string
	Value     string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	CreatedBy uuid.UUID
	TotalRows int64
}

func (q *Queries) GetLevelRequirementsByLevelID(ctx context.Context, arg GetLevelRequirementsByLevelIDParams) ([]GetLevelRequirementsByLevelIDRow, error) {
	rows, err := q.db.Query(ctx, getLevelRequirementsByLevelID, arg.LevelID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLevelRequirementsByLevelIDRow
	for rows.Next() {
		var i GetLevelRequirementsByLevelIDRow
		if err := rows.Scan(
			&i.ID,
			&i.LevelID,
			&i.Type,
			&i.Value,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLevels = `-- name: GetLevels :many
WITH level_data AS (
    SELECT id, level, created_at, updated_at, deleted_at, created_by, type
    FROM levels
    WHERE deleted_at IS NULL and type = $1
), row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM level_data
)
SELECT l.id, l.level, l.created_at, l.updated_at, l.deleted_at, l.created_by, l.type, r.total_rows
FROM level_data l
CROSS JOIN row_count r
ORDER BY l.created_at DESC
LIMIT $2 OFFSET $3
`

type GetLevelsParams struct {
	Type   string
	Limit  int32
	Offset int32
}

type GetLevelsRow struct {
	ID        uuid.UUID
	Level     decimal.Decimal
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	CreatedBy uuid.UUID
	Type      string
	TotalRows int64
}

func (q *Queries) GetLevels(ctx context.Context, arg GetLevelsParams) ([]GetLevelsRow, error) {
	rows, err := q.db.Query(ctx, getLevels, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLevelsRow
	for rows.Next() {
		var i GetLevelsRow
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.Type,
			&i.TotalRows,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadIDByOwnerID = `-- name: GetSquadIDByOwnerID :one
select id from squads where owner = $1 and deleted_at is null
`

func (q *Queries) GetSquadIDByOwnerID(ctx context.Context, owner uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, getSquadIDByOwnerID, owner)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getUserSquads = `-- name: GetUserSquads :many
SELECT s.id as squad_id from squads s JOIN squads_memebers sm ON s.id = sm.squad_id
WHERE sm.user_id = $1 AND sm.deleted_at IS NULL
`

func (q *Queries) GetUserSquads(ctx context.Context, userID uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getUserSquads, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var squad_id uuid.UUID
		if err := rows.Scan(&squad_id); err != nil {
			return nil, err
		}
		items = append(items, squad_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLevel = `-- name: UpdateLevel :one
UPDATE levels
SET level = $1, updated_at = CURRENT_TIMESTAMP
WHERE id = $2
RETURNING id, level, created_at, updated_at, deleted_at, created_by, type
`

type UpdateLevelParams struct {
	Level decimal.Decimal
	ID    uuid.UUID
}

func (q *Queries) UpdateLevel(ctx context.Context, arg UpdateLevelParams) (Level, error) {
	row := q.db.QueryRow(ctx, updateLevel, arg.Level, arg.ID)
	var i Level
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.Type,
	)
	return i, err
}

const updateLevelRequirement = `-- name: UpdateLevelRequirement :one
UPDATE level_requirements
SET type = $1, value = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $3
RETURNING id, level_id, type, value, created_at, updated_at, deleted_at, created_by
`

type UpdateLevelRequirementParams struct {
	Type  string
	Value string
	ID    uuid.UUID
}

func (q *Queries) UpdateLevelRequirement(ctx context.Context, arg UpdateLevelRequirementParams) (LevelRequirement, error) {
	row := q.db.QueryRow(ctx, updateLevelRequirement, arg.Type, arg.Value, arg.ID)
	var i LevelRequirement
	err := row.Scan(
		&i.ID,
		&i.LevelID,
		&i.Type,
		&i.Value,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
	)
	return i, err
}

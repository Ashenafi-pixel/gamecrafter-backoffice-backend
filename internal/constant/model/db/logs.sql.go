// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: logs.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createLoginAttemptsLog = `-- name: CreateLoginAttemptsLog :one
INSERT INTO login_attempts(user_id,ip_address,success,attempt_time,user_agent)
VALUES (
    $1,$2,$3,$4,$5
) RETURNING id, user_id, ip_address, success, attempt_time, user_agent
`

type CreateLoginAttemptsLogParams struct {
	UserID      uuid.NullUUID
	IpAddress   string
	Success     bool
	AttemptTime sql.NullTime
	UserAgent   sql.NullString
}

func (q *Queries) CreateLoginAttemptsLog(ctx context.Context, arg CreateLoginAttemptsLogParams) (LoginAttempt, error) {
	row := q.db.QueryRow(ctx, createLoginAttemptsLog,
		arg.UserID,
		arg.IpAddress,
		arg.Success,
		arg.AttemptTime,
		arg.UserAgent,
	)
	var i LoginAttempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.IpAddress,
		&i.Success,
		&i.AttemptTime,
		&i.UserAgent,
	)
	return i, err
}

const createSystemLog = `-- name: CreateSystemLog :one
INSERT INTO logs (user_id,module,detail,ip_address,timestamp) VALUES ($1,$2,$3,$4,$5) RETURNING id, user_id, module, detail, ip_address, timestamp
`

type CreateSystemLogParams struct {
	UserID    uuid.UUID
	Module    string
	Detail    pgtype.JSON
	IpAddress sql.NullString
	Timestamp sql.NullTime
}

func (q *Queries) CreateSystemLog(ctx context.Context, arg CreateSystemLogParams) (Log, error) {
	row := q.db.QueryRow(ctx, createSystemLog,
		arg.UserID,
		arg.Module,
		arg.Detail,
		arg.IpAddress,
		arg.Timestamp,
	)
	var i Log
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Module,
		&i.Detail,
		&i.IpAddress,
		&i.Timestamp,
	)
	return i, err
}

const createUserSessions = `-- name: CreateUserSessions :one
INSERT INTO user_sessions (user_id,token,expires_at,ip_address,user_agent,created_at,refresh_token,refresh_token_expires_at)
VALUES($1,$2,$3,$4,$5,$6,$7,$8) RETURNING id, user_id, token, expires_at, ip_address, user_agent, created_at, refresh_token, refresh_token_expires_at
`

type CreateUserSessionsParams struct {
	UserID                uuid.NullUUID
	Token                 string
	ExpiresAt             time.Time
	IpAddress             sql.NullString
	UserAgent             sql.NullString
	CreatedAt             sql.NullTime
	RefreshToken          sql.NullString
	RefreshTokenExpiresAt sql.NullTime
}

func (q *Queries) CreateUserSessions(ctx context.Context, arg CreateUserSessionsParams) (UserSession, error) {
	row := q.db.QueryRow(ctx, createUserSessions,
		arg.UserID,
		arg.Token,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
		arg.CreatedAt,
		arg.RefreshToken,
		arg.RefreshTokenExpiresAt,
	)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
	)
	return i, err
}

const deleteBalanceLog = `-- name: DeleteBalanceLog :exec
DELETE FROM bets where id = $1
`

func (q *Queries) DeleteBalanceLog(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBalanceLog, id)
	return err
}

const getAvailableModule = `-- name: GetAvailableModule :many
SELECT DISTINCT module FROM logs
`

func (q *Queries) GetAvailableModule(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAvailableModule)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var module string
		if err := rows.Scan(&module); err != nil {
			return nil, err
		}
		items = append(items, module)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttempts = `-- name: GetLoginAttempts :many
SELECT id, user_id, ip_address, success, attempt_time, user_agent FROM login_attempts OFFSET $1 LIMIT $2
`

type GetLoginAttemptsParams struct {
	Offset int32
	Limit  int32
}

func (q *Queries) GetLoginAttempts(ctx context.Context, arg GetLoginAttemptsParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getLoginAttempts, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginAttempt
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.IpAddress,
			&i.Success,
			&i.AttemptTime,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLoginAttemptsByUserID = `-- name: GetLoginAttemptsByUserID :many
SELECT id, user_id, ip_address, success, attempt_time, user_agent from login_attempts where user_id = $1 OFFSET $2 LIMIT $3
`

type GetLoginAttemptsByUserIDParams struct {
	UserID uuid.NullUUID
	Offset int32
	Limit  int32
}

func (q *Queries) GetLoginAttemptsByUserID(ctx context.Context, arg GetLoginAttemptsByUserIDParams) ([]LoginAttempt, error) {
	rows, err := q.db.Query(ctx, getLoginAttemptsByUserID, arg.UserID, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoginAttempt
	for rows.Next() {
		var i LoginAttempt
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.IpAddress,
			&i.Success,
			&i.AttemptTime,
			&i.UserAgent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsExpiringSoon = `-- name: GetSessionsExpiringSoon :many
SELECT id, user_id, token, expires_at, ip_address, user_agent, created_at, refresh_token, refresh_token_expires_at FROM user_sessions
WHERE refresh_token_expires_at > NOW()
  AND refresh_token_expires_at <= $1
`

func (q *Queries) GetSessionsExpiringSoon(ctx context.Context, refreshTokenExpiresAt sql.NullTime) ([]UserSession, error) {
	rows, err := q.db.Query(ctx, getSessionsExpiringSoon, refreshTokenExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserSession
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Token,
			&i.ExpiresAt,
			&i.IpAddress,
			&i.UserAgent,
			&i.CreatedAt,
			&i.RefreshToken,
			&i.RefreshTokenExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogs = `-- name: GetSystemLogs :many
WITH logs_data AS (
    SELECT id, user_id, module, ip_address, timestamp, detail
    FROM logs
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM logs_data 
),
roles_data AS (
    SELECT 
        ur.user_id,
        COALESCE(
            json_agg(
                json_build_object(
                    'name', rs.name,
                    'role_id', rs.id
                )
            ) FILTER (WHERE rs.id IS NOT NULL),
            '[]'::json
        ) AS roles
    FROM user_roles ur
    LEFT JOIN roles rs ON rs.id = ur.role_id
    GROUP BY ur.user_id
)
SELECT 
    c.id,
    c.user_id,
    c.module,
    c.ip_address,
    c.timestamp,
    c.detail,
    r.total_rows,
    COALESCE(rd.roles, '[]'::json) AS roles
FROM logs_data c 
CROSS JOIN row_count r
LEFT JOIN roles_data rd ON rd.user_id = c.user_id
ORDER BY c.timestamp DESC LIMIT $1 OFFSET $2
`

type GetSystemLogsParams struct {
	Limit  int32
	Offset int32
}

type GetSystemLogsRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Module    string
	IpAddress sql.NullString
	Timestamp sql.NullTime
	Detail    pgtype.JSON
	TotalRows int64
	Roles     interface{}
}

func (q *Queries) GetSystemLogs(ctx context.Context, arg GetSystemLogsParams) ([]GetSystemLogsRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSystemLogsRow
	for rows.Next() {
		var i GetSystemLogsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Module,
			&i.IpAddress,
			&i.Timestamp,
			&i.Detail,
			&i.TotalRows,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsByEndData = `-- name: GetSystemLogsByEndData :many
WITH logs_data AS (
    SELECT id, user_id, module, ip_address, timestamp, detail
    FROM logs where timestamp < $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM logs_data 
),
roles_data AS (
    SELECT 
        ur.user_id,
        COALESCE(
            json_agg(
                json_build_object(
                    'name', rs.name,
                    'role_id', rs.id
                )
            ) FILTER (WHERE rs.id IS NOT NULL),
            '[]'::json
        ) AS roles
    FROM user_roles ur
    LEFT JOIN roles rs ON rs.id = ur.role_id
    GROUP BY ur.user_id
)
SELECT 
    c.id,
    c.user_id,
    c.module,
    c.ip_address,
    c.timestamp,
    c.detail,
    r.total_rows,
    COALESCE(rd.roles, '[]'::json) AS roles
FROM logs_data c 
CROSS JOIN row_count r
LEFT JOIN roles_data rd ON rd.user_id = c.user_id
ORDER BY c.timestamp DESC LIMIT $2 OFFSET $3
`

type GetSystemLogsByEndDataParams struct {
	Timestamp sql.NullTime
	Limit     int32
	Offset    int32
}

type GetSystemLogsByEndDataRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Module    string
	IpAddress sql.NullString
	Timestamp sql.NullTime
	Detail    pgtype.JSON
	TotalRows int64
	Roles     interface{}
}

func (q *Queries) GetSystemLogsByEndData(ctx context.Context, arg GetSystemLogsByEndDataParams) ([]GetSystemLogsByEndDataRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByEndData, arg.Timestamp, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSystemLogsByEndDataRow
	for rows.Next() {
		var i GetSystemLogsByEndDataRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Module,
			&i.IpAddress,
			&i.Timestamp,
			&i.Detail,
			&i.TotalRows,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsByModule = `-- name: GetSystemLogsByModule :many
WITH logs_data AS (
    SELECT id, user_id, module, ip_address, timestamp, detail
    FROM logs where module = $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM logs_data 
),
roles_data AS (
    SELECT 
        ur.user_id,
        COALESCE(
            json_agg(
                json_build_object(
                    'name', rs.name,
                    'role_id', rs.id
                )
            ) FILTER (WHERE rs.id IS NOT NULL),
            '[]'::json
        ) AS roles
    FROM user_roles ur
    LEFT JOIN roles rs ON rs.id = ur.role_id
    GROUP BY ur.user_id
)
SELECT 
    c.id,
    c.user_id,
    c.module,
    c.ip_address,
    c.timestamp,
    c.detail,
    r.total_rows,
    COALESCE(rd.roles, '[]'::json) AS roles
FROM logs_data c 
CROSS JOIN row_count r
LEFT JOIN roles_data rd ON rd.user_id = c.user_id
ORDER BY c.timestamp DESC LIMIT $2 OFFSET $3
`

type GetSystemLogsByModuleParams struct {
	Module string
	Limit  int32
	Offset int32
}

type GetSystemLogsByModuleRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Module    string
	IpAddress sql.NullString
	Timestamp sql.NullTime
	Detail    pgtype.JSON
	TotalRows int64
	Roles     interface{}
}

func (q *Queries) GetSystemLogsByModule(ctx context.Context, arg GetSystemLogsByModuleParams) ([]GetSystemLogsByModuleRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByModule, arg.Module, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSystemLogsByModuleRow
	for rows.Next() {
		var i GetSystemLogsByModuleRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Module,
			&i.IpAddress,
			&i.Timestamp,
			&i.Detail,
			&i.TotalRows,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsByStartAndEndData = `-- name: GetSystemLogsByStartAndEndData :many
WITH logs_data AS (
    SELECT id, user_id, module, ip_address, timestamp, detail
    FROM logs where timestamp > $1 and timestamp < $2
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM logs_data 
),
roles_data AS (
    SELECT 
        ur.user_id,
        COALESCE(
            json_agg(
                json_build_object(
                    'name', rs.name,
                    'role_id', rs.id
                )
            ) FILTER (WHERE rs.id IS NOT NULL),
            '[]'::json
        ) AS roles
    FROM user_roles ur
    LEFT JOIN roles rs ON rs.id = ur.role_id
    GROUP BY ur.user_id
)
SELECT 
    c.id,
    c.user_id,
    c.module,
    c.ip_address,
    c.timestamp,
    c.detail,
    r.total_rows,
    COALESCE(rd.roles, '[]'::json) AS roles
FROM logs_data c 
CROSS JOIN row_count r
LEFT JOIN roles_data rd ON rd.user_id = c.user_id
ORDER BY c.timestamp DESC LIMIT $3 OFFSET $4
`

type GetSystemLogsByStartAndEndDataParams struct {
	Timestamp   sql.NullTime
	Timestamp_2 sql.NullTime
	Limit       int32
	Offset      int32
}

type GetSystemLogsByStartAndEndDataRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Module    string
	IpAddress sql.NullString
	Timestamp sql.NullTime
	Detail    pgtype.JSON
	TotalRows int64
	Roles     interface{}
}

func (q *Queries) GetSystemLogsByStartAndEndData(ctx context.Context, arg GetSystemLogsByStartAndEndDataParams) ([]GetSystemLogsByStartAndEndDataRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByStartAndEndData,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSystemLogsByStartAndEndDataRow
	for rows.Next() {
		var i GetSystemLogsByStartAndEndDataRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Module,
			&i.IpAddress,
			&i.Timestamp,
			&i.Detail,
			&i.TotalRows,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsByStartData = `-- name: GetSystemLogsByStartData :many
WITH logs_data AS (
    SELECT id, user_id, module, ip_address, timestamp, detail
    FROM logs where timestamp > $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM logs_data 
),
roles_data AS (
    SELECT 
        ur.user_id,
        COALESCE(
            json_agg(
                json_build_object(
                    'name', rs.name,
                    'role_id', rs.id
                )
            ) FILTER (WHERE rs.id IS NOT NULL),
            '[]'::json
        ) AS roles
    FROM user_roles ur
    LEFT JOIN roles rs ON rs.id = ur.role_id
    GROUP BY ur.user_id
)
SELECT 
    c.id,
    c.user_id,
    c.module,
    c.ip_address,
    c.timestamp,
    c.detail,
    r.total_rows,
    COALESCE(rd.roles, '[]'::json) AS roles
FROM logs_data c 
CROSS JOIN row_count r
LEFT JOIN roles_data rd ON rd.user_id = c.user_id
ORDER BY c.timestamp DESC LIMIT $2 OFFSET $3
`

type GetSystemLogsByStartDataParams struct {
	Timestamp sql.NullTime
	Limit     int32
	Offset    int32
}

type GetSystemLogsByStartDataRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Module    string
	IpAddress sql.NullString
	Timestamp sql.NullTime
	Detail    pgtype.JSON
	TotalRows int64
	Roles     interface{}
}

func (q *Queries) GetSystemLogsByStartData(ctx context.Context, arg GetSystemLogsByStartDataParams) ([]GetSystemLogsByStartDataRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByStartData, arg.Timestamp, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSystemLogsByStartDataRow
	for rows.Next() {
		var i GetSystemLogsByStartDataRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Module,
			&i.IpAddress,
			&i.Timestamp,
			&i.Detail,
			&i.TotalRows,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLogsByUserID = `-- name: GetSystemLogsByUserID :many
WITH logs_data AS (
    SELECT id, user_id, module, ip_address, timestamp, detail
    FROM logs where logs.user_id = $1
),
row_count AS (
    SELECT COUNT(*) AS total_rows
    FROM logs_data 
),
roles_data AS (
    SELECT 
        ur.user_id,
        COALESCE(
            json_agg(
                json_build_object(
                    'name', rs.name,
                    'role_id', rs.id
                )
            ) FILTER (WHERE rs.id IS NOT NULL),
            '[]'::json
        ) AS roles
    FROM user_roles ur
    LEFT JOIN roles rs ON rs.id = ur.role_id
    GROUP BY ur.user_id
)
SELECT 
    c.id,
    c.user_id,
    c.module,
    c.ip_address,
    c.timestamp,
    c.detail,
    r.total_rows,
    COALESCE(rd.roles, '[]'::json) AS roles
FROM logs_data c 
CROSS JOIN row_count r
LEFT JOIN roles_data rd ON rd.user_id = c.user_id
ORDER BY c.timestamp DESC LIMIT $2 OFFSET $3
`

type GetSystemLogsByUserIDParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetSystemLogsByUserIDRow struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	Module    string
	IpAddress sql.NullString
	Timestamp sql.NullTime
	Detail    pgtype.JSON
	TotalRows int64
	Roles     interface{}
}

func (q *Queries) GetSystemLogsByUserID(ctx context.Context, arg GetSystemLogsByUserIDParams) ([]GetSystemLogsByUserIDRow, error) {
	rows, err := q.db.Query(ctx, getSystemLogsByUserID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSystemLogsByUserIDRow
	for rows.Next() {
		var i GetSystemLogsByUserIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Module,
			&i.IpAddress,
			&i.Timestamp,
			&i.Detail,
			&i.TotalRows,
			&i.Roles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSessionByRefreshToken = `-- name: GetUserSessionByRefreshToken :one
SELECT id, user_id, token, expires_at, ip_address, user_agent, created_at, refresh_token, refresh_token_expires_at FROM user_sessions
WHERE refresh_token = $1
  AND refresh_token_expires_at > NOW()
`

func (q *Queries) GetUserSessionByRefreshToken(ctx context.Context, refreshToken sql.NullString) (UserSession, error) {
	row := q.db.QueryRow(ctx, getUserSessionByRefreshToken, refreshToken)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.CreatedAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
	)
	return i, err
}

const invalidateAllUserSessions = `-- name: InvalidateAllUserSessions :exec
UPDATE user_sessions
SET expires_at = NOW(),
    refresh_token_expires_at = NOW()
WHERE user_id = $1
`

func (q *Queries) InvalidateAllUserSessions(ctx context.Context, userID uuid.NullUUID) error {
	_, err := q.db.Exec(ctx, invalidateAllUserSessions, userID)
	return err
}

const invalidateOldUserSessions = `-- name: InvalidateOldUserSessions :exec
UPDATE user_sessions
SET expires_at = NOW()
WHERE user_id = $1 AND id != $2
`

type InvalidateOldUserSessionsParams struct {
	UserID uuid.NullUUID
	ID     uuid.UUID
}

func (q *Queries) InvalidateOldUserSessions(ctx context.Context, arg InvalidateOldUserSessionsParams) error {
	_, err := q.db.Exec(ctx, invalidateOldUserSessions, arg.UserID, arg.ID)
	return err
}

const updateUserSessionRefreshToken = `-- name: UpdateUserSessionRefreshToken :exec
UPDATE user_sessions
SET refresh_token = $2,
    refresh_token_expires_at = $3
WHERE id = $1
`

type UpdateUserSessionRefreshTokenParams struct {
	ID                    uuid.UUID
	RefreshToken          sql.NullString
	RefreshTokenExpiresAt sql.NullTime
}

func (q *Queries) UpdateUserSessionRefreshToken(ctx context.Context, arg UpdateUserSessionRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, updateUserSessionRefreshToken, arg.ID, arg.RefreshToken, arg.RefreshTokenExpiresAt)
	return err
}

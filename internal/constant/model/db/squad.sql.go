// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: squad.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
	"github.com/shopspring/decimal"
)

const addWaitingSquadMember = `-- name: AddWaitingSquadMember :one
INSERT INTO waiting_squad_members (user_id, squad_id, created_at) 
VALUES ($1, $2, $3)
RETURNING id, user_id, squad_id, created_at
`

type AddWaitingSquadMemberParams struct {
	UserID    uuid.UUID
	SquadID   uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) AddWaitingSquadMember(ctx context.Context, arg AddWaitingSquadMemberParams) (WaitingSquadMember, error) {
	row := q.db.QueryRow(ctx, addWaitingSquadMember, arg.UserID, arg.SquadID, arg.CreatedAt)
	var i WaitingSquadMember
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SquadID,
		&i.CreatedAt,
	)
	return i, err
}

const approveWaitingSquadMember = `-- name: ApproveWaitingSquadMember :exec
WITH new_member AS (
    INSERT INTO squads_memebers (squad_id, user_id, created_at, updated_at)
    SELECT wsm.squad_id, wsm.user_id, NOW(), NOW()
    FROM waiting_squad_members wsm
    WHERE wsm.id = $1
    RETURNING squads_memebers.id, squad_id, user_id, created_at, updated_at
)
DELETE FROM waiting_squad_members 
WHERE waiting_squad_members.id = $1
`

func (q *Queries) ApproveWaitingSquadMember(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, approveWaitingSquadMember, id)
	return err
}

const createSquad = `-- name: CreateSquad :one
INSERT INTO squads (handle, owner, type, created_at) values ($1, $2, $3, $4)
RETURNING id, handle, owner, created_at, updated_at, deleted_at, type
`

type CreateSquadParams struct {
	Handle    string
	Owner     uuid.UUID
	Type      string
	CreatedAt time.Time
}

func (q *Queries) CreateSquad(ctx context.Context, arg CreateSquadParams) (Squad, error) {
	row := q.db.QueryRow(ctx, createSquad,
		arg.Handle,
		arg.Owner,
		arg.Type,
		arg.CreatedAt,
	)
	var i Squad
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}

const createSquadEarn = `-- name: CreateSquadEarn :one
INSERT INTO squads_earns (squad_id, user_id, currency, earned, game_id, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, squad_id, user_id, currency, earned, game_id, created_at, updated_at, deleted_at
`

type CreateSquadEarnParams struct {
	SquadID   uuid.UUID
	UserID    uuid.UUID
	Currency  string
	Earned    decimal.Decimal
	GameID    uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateSquadEarn(ctx context.Context, arg CreateSquadEarnParams) (SquadsEarn, error) {
	row := q.db.QueryRow(ctx, createSquadEarn,
		arg.SquadID,
		arg.UserID,
		arg.Currency,
		arg.Earned,
		arg.GameID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SquadsEarn
	err := row.Scan(
		&i.ID,
		&i.SquadID,
		&i.UserID,
		&i.Currency,
		&i.Earned,
		&i.GameID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createSquadMember = `-- name: CreateSquadMember :one
INSERT INTO squads_memebers (squad_id, user_id, created_at, updated_at) VALUES ($1, $2, $3, $4) RETURNING id, squad_id, user_id, created_at, updated_at, deleted_at
`

type CreateSquadMemberParams struct {
	SquadID   uuid.UUID
	UserID    uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateSquadMember(ctx context.Context, arg CreateSquadMemberParams) (SquadsMemeber, error) {
	row := q.db.QueryRow(ctx, createSquadMember,
		arg.SquadID,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i SquadsMemeber
	err := row.Scan(
		&i.ID,
		&i.SquadID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createTournamentClaim = `-- name: CreateTournamentClaim :one
INSERT INTO tournaments_claims (tournament_id, squad_id, claimed_at) 
VALUES ($1, $2, $3)
RETURNING id, tournament_id, squad_id, claimed_at
`

type CreateTournamentClaimParams struct {
	TournamentID uuid.UUID
	SquadID      uuid.UUID
	ClaimedAt    time.Time
}

func (q *Queries) CreateTournamentClaim(ctx context.Context, arg CreateTournamentClaimParams) (TournamentsClaim, error) {
	row := q.db.QueryRow(ctx, createTournamentClaim, arg.TournamentID, arg.SquadID, arg.ClaimedAt)
	var i TournamentsClaim
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.SquadID,
		&i.ClaimedAt,
	)
	return i, err
}

const createTournaments = `-- name: CreateTournaments :one
INSERT INTO tournaments (rank, level, cumulative_points, rewards, created_at, updated_at) 
VALUES ($1, $2, $3, $4, $5, $6) 
RETURNING id, rank, level, cumulative_points, rewards, created_at, updated_at, deleted_at
`

type CreateTournamentsParams struct {
	Rank             string
	Level            int32
	CumulativePoints int32
	Rewards          pgtype.JSONB
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) CreateTournaments(ctx context.Context, arg CreateTournamentsParams) (Tournament, error) {
	row := q.db.QueryRow(ctx, createTournaments,
		arg.Rank,
		arg.Level,
		arg.CumulativePoints,
		arg.Rewards,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Tournament
	err := row.Scan(
		&i.ID,
		&i.Rank,
		&i.Level,
		&i.CumulativePoints,
		&i.Rewards,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteSquad = `-- name: DeleteSquad :exec
UPDATE squads SET deleted_at = $1, updated_at = $2
WHERE id = $3
`

type DeleteSquadParams struct {
	DeletedAt sql.NullTime
	UpdatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) DeleteSquad(ctx context.Context, arg DeleteSquadParams) error {
	_, err := q.db.Exec(ctx, deleteSquad, arg.DeletedAt, arg.UpdatedAt, arg.ID)
	return err
}

const deleteSquadMember = `-- name: DeleteSquadMember :exec
UPDATE squads_memebers SET deleted_at = $1, updated_at = $2
WHERE id = $3
`

type DeleteSquadMemberParams struct {
	DeletedAt sql.NullTime
	UpdatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) DeleteSquadMember(ctx context.Context, arg DeleteSquadMemberParams) error {
	_, err := q.db.Exec(ctx, deleteSquadMember, arg.DeletedAt, arg.UpdatedAt, arg.ID)
	return err
}

const deleteSquadMemberByID = `-- name: DeleteSquadMemberByID :exec
UPDATE squads_memebers SET deleted_at = now(), updated_at = now()
WHERE id = $1 and deleted_at IS NULL
`

func (q *Queries) DeleteSquadMemberByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSquadMemberByID, id)
	return err
}

const deleteSquadMembersBySquadId = `-- name: DeleteSquadMembersBySquadId :exec
UPDATE squads_memebers SET deleted_at = $1, updated_at = $2
WHERE squad_id = $3
`

type DeleteSquadMembersBySquadIdParams struct {
	DeletedAt sql.NullTime
	UpdatedAt time.Time
	SquadID   uuid.UUID
}

func (q *Queries) DeleteSquadMembersBySquadId(ctx context.Context, arg DeleteSquadMembersBySquadIdParams) error {
	_, err := q.db.Exec(ctx, deleteSquadMembersBySquadId, arg.DeletedAt, arg.UpdatedAt, arg.SquadID)
	return err
}

const deleteWaitingSquadMember = `-- name: DeleteWaitingSquadMember :exec
DELETE FROM waiting_squad_members 
WHERE id = $1
`

func (q *Queries) DeleteWaitingSquadMember(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWaitingSquadMember, id)
	return err
}

const deleteWaitingSquadMembersBySquadID = `-- name: DeleteWaitingSquadMembersBySquadID :exec
DELETE FROM waiting_squad_members 
WHERE squad_id = $1
`

func (q *Queries) DeleteWaitingSquadMembersBySquadID(ctx context.Context, squadID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWaitingSquadMembersBySquadID, squadID)
	return err
}

const getSquadById = `-- name: GetSquadById :one
SELECT id, handle, owner, type, created_at, updated_at, deleted_at from squads WHERE id = $1
`

type GetSquadByIdRow struct {
	ID        uuid.UUID
	Handle    string
	Owner     uuid.UUID
	Type      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

func (q *Queries) GetSquadById(ctx context.Context, id uuid.UUID) (GetSquadByIdRow, error) {
	row := q.db.QueryRow(ctx, getSquadById, id)
	var i GetSquadByIdRow
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Owner,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSquadByOwner = `-- name: GetSquadByOwner :many
SELECT id, handle, owner, type, created_at, updated_at, deleted_at 
FROM squads 
WHERE owner IN (SELECT squad_id FROM squads_memebers WHERE user_id = $1 AND deleted_at IS NULL)
AND deleted_at IS NULL
`

type GetSquadByOwnerRow struct {
	ID        uuid.UUID
	Handle    string
	Owner     uuid.UUID
	Type      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

func (q *Queries) GetSquadByOwner(ctx context.Context, userID uuid.UUID) ([]GetSquadByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getSquadByOwner, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadByOwnerRow
	for rows.Next() {
		var i GetSquadByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Handle,
			&i.Owner,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadByUserID = `-- name: GetSquadByUserID :one
WITH squad_members AS (
    SELECT 
        s.id,
        s.handle,
        s.owner,
        s.type,
        s.created_at,
        s.updated_at,
        s.deleted_at,
        u.first_name,
        u.last_name,
        u.id as owner_id,
        u.phone_number
    FROM squads s
    JOIN squads_memebers sm ON s.id = sm.squad_id JOIN users u ON s.owner = u.id
    WHERE sm.user_id = $1 AND s.deleted_at IS NULL AND sm.deleted_at IS NULL
)
SELECT id, handle, owner, type, created_at, updated_at, deleted_at, first_name, last_name, owner_id, phone_number 
FROM squad_members
ORDER BY created_at DESC
`

type GetSquadByUserIDRow struct {
	ID          uuid.UUID
	Handle      string
	Owner       uuid.UUID
	Type        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	FirstName   sql.NullString
	LastName    sql.NullString
	OwnerID     uuid.UUID
	PhoneNumber sql.NullString
}

func (q *Queries) GetSquadByUserID(ctx context.Context, userID uuid.UUID) (GetSquadByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getSquadByUserID, userID)
	var i GetSquadByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Owner,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.FirstName,
		&i.LastName,
		&i.OwnerID,
		&i.PhoneNumber,
	)
	return i, err
}

const getSquadByUserIDFromSquadMember = `-- name: GetSquadByUserIDFromSquadMember :many
SELECT 
    s.id, 
    s.handle, 
    s.type, 
    s.created_at, 
    s.updated_at, 
    s.deleted_at,
    s.owner,
    sm.id AS member_id
FROM 
    squads s
JOIN 
    squads_memebers sm 
ON 
    s.id = sm.squad_id
WHERE 
    sm.user_id = $1 
    AND s.deleted_at IS NULL
    AND sm.deleted_at IS NULL
`

type GetSquadByUserIDFromSquadMemberRow struct {
	ID        uuid.UUID
	Handle    string
	Type      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
	Owner     uuid.UUID
	MemberID  uuid.UUID
}

func (q *Queries) GetSquadByUserIDFromSquadMember(ctx context.Context, userID uuid.UUID) ([]GetSquadByUserIDFromSquadMemberRow, error) {
	rows, err := q.db.Query(ctx, getSquadByUserIDFromSquadMember, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadByUserIDFromSquadMemberRow
	for rows.Next() {
		var i GetSquadByUserIDFromSquadMemberRow
		if err := rows.Scan(
			&i.ID,
			&i.Handle,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Owner,
			&i.MemberID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadByhandle = `-- name: GetSquadByhandle :one
SELECT id, handle, owner, type, created_at, updated_at, deleted_at from squads WHERE handle = $1
`

type GetSquadByhandleRow struct {
	ID        uuid.UUID
	Handle    string
	Owner     uuid.UUID
	Type      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

func (q *Queries) GetSquadByhandle(ctx context.Context, handle string) (GetSquadByhandleRow, error) {
	row := q.db.QueryRow(ctx, getSquadByhandle, handle)
	var i GetSquadByhandleRow
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Owner,
		&i.Type,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSquadEarningsAmountBySquadID = `-- name: GetSquadEarningsAmountBySquadID :one
SELECT COALESCE(SUM(earned), 0)::decimal 
FROM squads_earns 
WHERE squad_id = $1 
AND deleted_at IS NULL
`

func (q *Queries) GetSquadEarningsAmountBySquadID(ctx context.Context, squadID uuid.UUID) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getSquadEarningsAmountBySquadID, squadID)
	var column_1 decimal.Decimal
	err := row.Scan(&column_1)
	return column_1, err
}

const getSquadEarnsBySquadId = `-- name: GetSquadEarnsBySquadId :many
WITH squadEarns AS (
    SELECT 
        COUNT(*) OVER () AS total, 
        id, 
        squad_id, 
        user_id, 
        currency, 
        earned, 
        game_id, 
        created_at, 
        updated_at, 
        deleted_at 
    FROM squads_earns 
    WHERE squad_id = $1 
    AND deleted_at IS NULL
)
SELECT total, id, squad_id, user_id, currency, earned, game_id, created_at, updated_at, deleted_at 
FROM squadEarns
ORDER BY created_at DESC 
LIMIT $2 OFFSET $3
`

type GetSquadEarnsBySquadIdParams struct {
	SquadID uuid.UUID
	Limit   int32
	Offset  int32
}

type GetSquadEarnsBySquadIdRow struct {
	Total     int64
	ID        uuid.UUID
	SquadID   uuid.UUID
	UserID    uuid.UUID
	Currency  string
	Earned    decimal.Decimal
	GameID    uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

func (q *Queries) GetSquadEarnsBySquadId(ctx context.Context, arg GetSquadEarnsBySquadIdParams) ([]GetSquadEarnsBySquadIdRow, error) {
	rows, err := q.db.Query(ctx, getSquadEarnsBySquadId, arg.SquadID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadEarnsBySquadIdRow
	for rows.Next() {
		var i GetSquadEarnsBySquadIdRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.SquadID,
			&i.UserID,
			&i.Currency,
			&i.Earned,
			&i.GameID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadEarnsByUserIdAndSquadID = `-- name: GetSquadEarnsByUserIdAndSquadID :many
WITH squadEarns AS (
    SELECT 
        COUNT(*) OVER () AS total, 
        id, 
        squad_id, 
        user_id, 
        currency, 
        earned, 
        game_id, 
        created_at, 
        updated_at, 
        deleted_at 
    FROM squads_earns 
    WHERE squad_id = $1 and user_id = $2
    AND deleted_at IS NULL
)
SELECT total, id, squad_id, user_id, currency, earned, game_id, created_at, updated_at, deleted_at 
FROM squadEarns
ORDER BY created_at DESC 
LIMIT $3 OFFSET $4
`

type GetSquadEarnsByUserIdAndSquadIDParams struct {
	SquadID uuid.UUID
	UserID  uuid.UUID
	Limit   int32
	Offset  int32
}

type GetSquadEarnsByUserIdAndSquadIDRow struct {
	Total     int64
	ID        uuid.UUID
	SquadID   uuid.UUID
	UserID    uuid.UUID
	Currency  string
	Earned    decimal.Decimal
	GameID    uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

func (q *Queries) GetSquadEarnsByUserIdAndSquadID(ctx context.Context, arg GetSquadEarnsByUserIdAndSquadIDParams) ([]GetSquadEarnsByUserIdAndSquadIDRow, error) {
	rows, err := q.db.Query(ctx, getSquadEarnsByUserIdAndSquadID,
		arg.SquadID,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadEarnsByUserIdAndSquadIDRow
	for rows.Next() {
		var i GetSquadEarnsByUserIdAndSquadIDRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.SquadID,
			&i.UserID,
			&i.Currency,
			&i.Earned,
			&i.GameID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadMemberById = `-- name: GetSquadMemberById :one
SELECT 
    sm.id, sm.squad_id, sm.user_id, sm.created_at, sm.updated_at, sm.deleted_at, 
    s.handle AS squad_handle, 
    s.owner AS squad_owner
FROM 
    squads_memebers sm
JOIN 
    squads s 
ON 
    sm.squad_id = s.id
WHERE 
    sm.id = $1 
    AND sm.deleted_at IS NULL
`

type GetSquadMemberByIdRow struct {
	ID          uuid.UUID
	SquadID     uuid.UUID
	UserID      uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	SquadHandle string
	SquadOwner  uuid.UUID
}

func (q *Queries) GetSquadMemberById(ctx context.Context, id uuid.UUID) (GetSquadMemberByIdRow, error) {
	row := q.db.QueryRow(ctx, getSquadMemberById, id)
	var i GetSquadMemberByIdRow
	err := row.Scan(
		&i.ID,
		&i.SquadID,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.SquadHandle,
		&i.SquadOwner,
	)
	return i, err
}

const getSquadMembersBySquadId = `-- name: GetSquadMembersBySquadId :many
WITH squad_memebers as (
    SELECT count(*) as total, sm.id, squad_id, user_id, sm.created_at, updated_at, deleted_at, us.first_name, us.last_name, us.phone_number from squads_memebers sm join users us on sm.user_id = us.id WHERE squad_id = $1 AND deleted_at IS NULL
    GROUP BY sm.id, squad_id, user_id, sm.created_at, updated_at, deleted_at, us.first_name, us.last_name, us.phone_number
)
SELECT total, id, squad_id, user_id, created_at, updated_at, deleted_at, first_name, last_name, phone_number 
FROM squad_memebers
ORDER BY created_at DESC 
LIMIT $2 OFFSET $3
`

type GetSquadMembersBySquadIdParams struct {
	SquadID uuid.UUID
	Limit   int32
	Offset  int32
}

type GetSquadMembersBySquadIdRow struct {
	Total       int64
	ID          uuid.UUID
	SquadID     uuid.UUID
	UserID      uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	FirstName   sql.NullString
	LastName    sql.NullString
	PhoneNumber sql.NullString
}

func (q *Queries) GetSquadMembersBySquadId(ctx context.Context, arg GetSquadMembersBySquadIdParams) ([]GetSquadMembersBySquadIdRow, error) {
	rows, err := q.db.Query(ctx, getSquadMembersBySquadId, arg.SquadID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadMembersBySquadIdRow
	for rows.Next() {
		var i GetSquadMembersBySquadIdRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.SquadID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadMembersByUserId = `-- name: GetSquadMembersByUserId :many
SELECT sm.id, squad_id, user_id, sm.created_at, updated_at, deleted_at, us.first_name, us.last_name, us.phone_number from squads_memebers sm JOIN users us on sm.user_id = us.id  WHERE user_id = $1 AND deleted_at IS NULL
`

type GetSquadMembersByUserIdRow struct {
	ID          uuid.UUID
	SquadID     uuid.UUID
	UserID      uuid.UUID
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	FirstName   sql.NullString
	LastName    sql.NullString
	PhoneNumber sql.NullString
}

func (q *Queries) GetSquadMembersByUserId(ctx context.Context, userID uuid.UUID) ([]GetSquadMembersByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getSquadMembersByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadMembersByUserIdRow
	for rows.Next() {
		var i GetSquadMembersByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.SquadID,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadMembersEarnings = `-- name: GetSquadMembersEarnings :many
WITH squad_members_earnings AS (
    SELECT 
        COUNT(*) OVER () AS total,
        sm.user_id,
        u.first_name,
        u.last_name,
        u.phone_number,
        COALESCE(SUM(se.earned), 0)::decimal AS total_earned,
        COUNT(se.id) AS total_games,
        MAX(se.created_at) AS last_earned_at
    FROM squads_memebers sm
    LEFT JOIN users u ON sm.user_id = u.id
    LEFT JOIN squads s ON sm.squad_id = s.id
    LEFT JOIN squads_earns se ON sm.user_id = se.user_id AND sm.squad_id = se.squad_id AND se.deleted_at IS NULL
    WHERE sm.squad_id = $1 
    AND s.owner = $2
    AND sm.deleted_at IS NULL
    GROUP BY sm.user_id, u.first_name, u.last_name, u.phone_number
)
SELECT total, user_id, first_name, last_name, phone_number, total_earned, total_games, last_earned_at 
FROM squad_members_earnings
ORDER BY total_earned DESC
LIMIT $3 OFFSET $4
`

type GetSquadMembersEarningsParams struct {
	SquadID uuid.UUID
	Owner   uuid.UUID
	Limit   int32
	Offset  int32
}

type GetSquadMembersEarningsRow struct {
	Total        int64
	UserID       uuid.UUID
	FirstName    sql.NullString
	LastName     sql.NullString
	PhoneNumber  sql.NullString
	TotalEarned  decimal.Decimal
	TotalGames   int64
	LastEarnedAt interface{}
}

func (q *Queries) GetSquadMembersEarnings(ctx context.Context, arg GetSquadMembersEarningsParams) ([]GetSquadMembersEarningsRow, error) {
	rows, err := q.db.Query(ctx, getSquadMembersEarnings,
		arg.SquadID,
		arg.Owner,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadMembersEarningsRow
	for rows.Next() {
		var i GetSquadMembersEarningsRow
		if err := rows.Scan(
			&i.Total,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.TotalEarned,
			&i.TotalGames,
			&i.LastEarnedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadTotalEarnsBySquadID = `-- name: GetSquadTotalEarnsBySquadID :one
SELECT COALESCE(sum (earned), 0)::decimal from squads_earns WHERE squad_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetSquadTotalEarnsBySquadID(ctx context.Context, squadID uuid.UUID) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getSquadTotalEarnsBySquadID, squadID)
	var column_1 decimal.Decimal
	err := row.Scan(&column_1)
	return column_1, err
}

const getSquadsByOwner = `-- name: GetSquadsByOwner :many
WITH squad_members AS (
    SELECT 
        COUNT(*) OVER () AS total,
        s.id,
        s.handle,
        s.owner,
        s.type,
        s.created_at,
        s.updated_at,
        s.deleted_at,
        u.first_name,
        u.last_name,
        u.phone_number,
        u.id as owner_id
    FROM squads s JOIN users u ON s.owner = u.id
    WHERE s.owner = $1 AND s.deleted_at IS NULL
)
SELECT total, id, handle, owner, type, created_at, updated_at, deleted_at, first_name, last_name, phone_number, owner_id 
FROM squad_members
ORDER BY created_at DESC
`

type GetSquadsByOwnerRow struct {
	Total       int64
	ID          uuid.UUID
	Handle      string
	Owner       uuid.UUID
	Type        string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	DeletedAt   sql.NullTime
	FirstName   sql.NullString
	LastName    sql.NullString
	PhoneNumber sql.NullString
	OwnerID     uuid.UUID
}

func (q *Queries) GetSquadsByOwner(ctx context.Context, owner uuid.UUID) ([]GetSquadsByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getSquadsByOwner, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadsByOwnerRow
	for rows.Next() {
		var i GetSquadsByOwnerRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.Handle,
			&i.Owner,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSquadsByType = `-- name: GetSquadsByType :many
SELECT id, handle, owner, type, created_at, updated_at, deleted_at from squads WHERE type = $1 AND deleted_at IS NULL
`

type GetSquadsByTypeRow struct {
	ID        uuid.UUID
	Handle    string
	Owner     uuid.UUID
	Type      string
	CreatedAt time.Time
	UpdatedAt time.Time
	DeletedAt sql.NullTime
}

func (q *Queries) GetSquadsByType(ctx context.Context, type_ string) ([]GetSquadsByTypeRow, error) {
	rows, err := q.db.Query(ctx, getSquadsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSquadsByTypeRow
	for rows.Next() {
		var i GetSquadsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Handle,
			&i.Owner,
			&i.Type,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTornamentStyleRanking = `-- name: GetTornamentStyleRanking :many
WITH squadEarnings AS (
    SELECT 
        COUNT(*) OVER () AS total, 
        se.squad_id, 
        s.handle, 
        SUM(se.earned) AS total_earned,
        DATE_TRUNC('day', se.created_at) AS day
    FROM squads_earns se
    JOIN squads s ON se.squad_id = s.id
    WHERE se.created_at >= NOW() - INTERVAL '6 days'
    AND se.deleted_at IS NULL
    GROUP BY se.squad_id, s.handle, DATE_TRUNC('day', se.created_at)
)
SELECT 
    squad_id, 
    handle, 
    total,
    SUM(total_earned)::decimal AS total_earned,
    ARRAY_AGG(DISTINCT day) AS days,
    RANK() OVER (ORDER BY SUM(total_earned) DESC) AS rank
FROM squadEarnings
GROUP BY squad_id, handle, total
ORDER BY total_earned DESC
LIMIT $1 OFFSET $2
`

type GetTornamentStyleRankingParams struct {
	Limit  int32
	Offset int32
}

type GetTornamentStyleRankingRow struct {
	SquadID     uuid.UUID
	Handle      string
	Total       int64
	TotalEarned decimal.Decimal
	Days        interface{}
	Rank        int64
}

func (q *Queries) GetTornamentStyleRanking(ctx context.Context, arg GetTornamentStyleRankingParams) ([]GetTornamentStyleRankingRow, error) {
	rows, err := q.db.Query(ctx, getTornamentStyleRanking, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTornamentStyleRankingRow
	for rows.Next() {
		var i GetTornamentStyleRankingRow
		if err := rows.Scan(
			&i.SquadID,
			&i.Handle,
			&i.Total,
			&i.TotalEarned,
			&i.Days,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTornamentStyles = `-- name: GetTornamentStyles :many
SELECT id, rank, level, cumulative_points, rewards, created_at, updated_at 
FROM tournaments 
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

type GetTornamentStylesRow struct {
	ID               uuid.UUID
	Rank             string
	Level            int32
	CumulativePoints int32
	Rewards          pgtype.JSONB
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) GetTornamentStyles(ctx context.Context) ([]GetTornamentStylesRow, error) {
	rows, err := q.db.Query(ctx, getTornamentStyles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTornamentStylesRow
	for rows.Next() {
		var i GetTornamentStylesRow
		if err := rows.Scan(
			&i.ID,
			&i.Rank,
			&i.Level,
			&i.CumulativePoints,
			&i.Rewards,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournamentClaimBySquadID = `-- name: GetTournamentClaimBySquadID :one
SELECT id, tournament_id, squad_id, claimed_at 
FROM tournaments_claims 
WHERE squad_id = $1 
AND tournament_id = $2 
AND claimed_at IS NOT NULL
AND deleted_at IS NULL
`

type GetTournamentClaimBySquadIDParams struct {
	SquadID      uuid.UUID
	TournamentID uuid.UUID
}

func (q *Queries) GetTournamentClaimBySquadID(ctx context.Context, arg GetTournamentClaimBySquadIDParams) (TournamentsClaim, error) {
	row := q.db.QueryRow(ctx, getTournamentClaimBySquadID, arg.SquadID, arg.TournamentID)
	var i TournamentsClaim
	err := row.Scan(
		&i.ID,
		&i.TournamentID,
		&i.SquadID,
		&i.ClaimedAt,
	)
	return i, err
}

const getTournamentClaimByTournamentID = `-- name: GetTournamentClaimByTournamentID :many
SELECT id, tournament_id, squad_id, claimed_at 
FROM tournaments_claims 
WHERE tournament_id = $1 
AND claimed_at IS NOT NULL
AND deleted_at IS NULL
`

func (q *Queries) GetTournamentClaimByTournamentID(ctx context.Context, tournamentID uuid.UUID) ([]TournamentsClaim, error) {
	rows, err := q.db.Query(ctx, getTournamentClaimByTournamentID, tournamentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TournamentsClaim
	for rows.Next() {
		var i TournamentsClaim
		if err := rows.Scan(
			&i.ID,
			&i.TournamentID,
			&i.SquadID,
			&i.ClaimedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTournaments = `-- name: GetTournaments :many
WITH tournaments AS (
    SELECT 
        COUNT(*) OVER () AS total, 
        id, 
        rank, 
        level, 
        cumulative_points, 
        rewards, 
        created_at, 
        updated_at 
    FROM tournaments 
    WHERE deleted_at IS NULL
)
SELECT total, id, rank, level, cumulative_points, rewards, created_at, updated_at 
FROM tournaments
ORDER BY created_at DESC 
LIMIT $1 OFFSET $2
`

type GetTournamentsParams struct {
	Limit  int32
	Offset int32
}

type GetTournamentsRow struct {
	Total            int64
	ID               uuid.UUID
	Rank             string
	Level            int32
	CumulativePoints int32
	Rewards          pgtype.JSONB
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) GetTournaments(ctx context.Context, arg GetTournamentsParams) ([]GetTournamentsRow, error) {
	rows, err := q.db.Query(ctx, getTournaments, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTournamentsRow
	for rows.Next() {
		var i GetTournamentsRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.Rank,
			&i.Level,
			&i.CumulativePoints,
			&i.Rewards,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEarnsForSquad = `-- name: GetUserEarnsForSquad :one
SELECT COALESCE(sum (earned), 0)::decimal from squads_earns WHERE squad_id = $1 AND user_id = $2 AND deleted_at IS NULL
`

type GetUserEarnsForSquadParams struct {
	SquadID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) GetUserEarnsForSquad(ctx context.Context, arg GetUserEarnsForSquadParams) (decimal.Decimal, error) {
	row := q.db.QueryRow(ctx, getUserEarnsForSquad, arg.SquadID, arg.UserID)
	var column_1 decimal.Decimal
	err := row.Scan(&column_1)
	return column_1, err
}

const getWaitingSquadMemberOwner = `-- name: GetWaitingSquadMemberOwner :one
SELECT 
    wsm.id, 
    wsm.user_id, 
    wsm.squad_id,
    wsm.created_at,
    u.id AS owner_id,
    u.first_name,
    u.last_name,
    u.phone_number
FROM 
    waiting_squad_members wsm
JOIN 
    squads s 
ON 
    wsm.squad_id = s.squad_id
JOIN 
    users u 
ON 
    s.owner = u.id
WHERE 
    wsm.id = $1 and wsm.deleted_at IS NULL
`

type GetWaitingSquadMemberOwnerRow struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	SquadID     uuid.UUID
	CreatedAt   time.Time
	OwnerID     uuid.UUID
	FirstName   sql.NullString
	LastName    sql.NullString
	PhoneNumber sql.NullString
}

func (q *Queries) GetWaitingSquadMemberOwner(ctx context.Context, id uuid.UUID) (GetWaitingSquadMemberOwnerRow, error) {
	row := q.db.QueryRow(ctx, getWaitingSquadMemberOwner, id)
	var i GetWaitingSquadMemberOwnerRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SquadID,
		&i.CreatedAt,
		&i.OwnerID,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
	)
	return i, err
}

const getWaitingSquadMembersBySquadID = `-- name: GetWaitingSquadMembersBySquadID :many
SELECT 
    COUNT(*) OVER () AS total,
    wsm.id,
    wsm.user_id,
    wsm.squad_id,
    wsm.created_at,
    u.first_name,
    u.last_name,
    u.phone_number
FROM 
    waiting_squad_members wsm
JOIN 
    users u 
ON 
    wsm.user_id = u.id
WHERE 
    wsm.squad_id = $1
`

type GetWaitingSquadMembersBySquadIDRow struct {
	Total       int64
	ID          uuid.UUID
	UserID      uuid.UUID
	SquadID     uuid.UUID
	CreatedAt   time.Time
	FirstName   sql.NullString
	LastName    sql.NullString
	PhoneNumber sql.NullString
}

func (q *Queries) GetWaitingSquadMembersBySquadID(ctx context.Context, squadID uuid.UUID) ([]GetWaitingSquadMembersBySquadIDRow, error) {
	rows, err := q.db.Query(ctx, getWaitingSquadMembersBySquadID, squadID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWaitingSquadMembersBySquadIDRow
	for rows.Next() {
		var i GetWaitingSquadMembersBySquadIDRow
		if err := rows.Scan(
			&i.Total,
			&i.ID,
			&i.UserID,
			&i.SquadID,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const leaveSquad = `-- name: LeaveSquad :exec
UPDATE squads_memebers SET deleted_at = now(), updated_at = now()
WHERE user_id = $1 AND squad_id = $2 AND deleted_at IS NULL
`

type LeaveSquadParams struct {
	UserID  uuid.UUID
	SquadID uuid.UUID
}

func (q *Queries) LeaveSquad(ctx context.Context, arg LeaveSquadParams) error {
	_, err := q.db.Exec(ctx, leaveSquad, arg.UserID, arg.SquadID)
	return err
}

const updateSquad = `-- name: UpdateSquad :one
UPDATE squads SET handle = $1, type = $2, updated_at = $3
WHERE id = $4 RETURNING id, handle, owner, created_at, updated_at, deleted_at, type
`

type UpdateSquadParams struct {
	Handle    string
	Type      string
	UpdatedAt time.Time
	ID        uuid.UUID
}

func (q *Queries) UpdateSquad(ctx context.Context, arg UpdateSquadParams) (Squad, error) {
	row := q.db.QueryRow(ctx, updateSquad,
		arg.Handle,
		arg.Type,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Squad
	err := row.Scan(
		&i.ID,
		&i.Handle,
		&i.Owner,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Type,
	)
	return i, err
}
